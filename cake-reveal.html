<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,maximum-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-touch-fullscreen" content="yes">
<title>ğŸ‚ Cake Reveal v12.0 - AIå¢å¼·ç‰ˆ (æ™ºèƒ½æ¸¬å…‰+Guided Filterç´°ç¯€+æ€§èƒ½å„ªåŒ–)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
  :root{
    --bg:#0b1220;--panel:#0f1b2e;--text:#e9f0ff;--brand:#2be38a;
    --border:#1b2a45;--btn:#20314f;--warning:#ff9500;
  }
  html,body{width:100%;height:100%;background:var(--bg);color:var(--text);
    font-family:-apple-system,system-ui,sans-serif;overflow:hidden;position:fixed;
    -webkit-user-select:none;-webkit-font-smoothing:antialiased;}
  
  /* ç™»å…¥ç•«é¢æ¨£å¼ */
  #loginScreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:10000;}
  #loginScreen.hidden{display:none;}
  .loginBox{background:var(--panel);border:2px solid var(--border);
    border-radius:16px;padding:32px;max-width:360px;width:90%;
    box-shadow:0 8px 32px rgba(0,0,0,0.6);}
  .loginBox h2{font-size:24px;margin-bottom:8px;text-align:center;color:var(--brand);}
  .loginBox .subtitle{font-size:12px;color:#7a92c0;text-align:center;margin-bottom:24px;}
  .loginBox .inputGroup{margin-bottom:16px;}
  .loginBox .inputGroup label{display:block;font-size:12px;color:#b7c7e6;
    margin-bottom:6px;font-weight:600;}
  .loginBox .inputGroup input{width:100%;background:var(--btn);
    border:1px solid var(--border);border-radius:8px;padding:12px;
    color:var(--text);font-size:14px;outline:none;transition:all 0.2s;}
  .loginBox .inputGroup input:focus{border-color:var(--brand);
    box-shadow:0 0 0 3px rgba(43,227,138,0.1);}
  .loginBox .loginBtn{width:100%;background:var(--brand);border:none;
    border-radius:8px;padding:14px;font-weight:700;font-size:14px;
    color:#072412;cursor:pointer;transition:all 0.2s;margin-top:8px;}
  .loginBox .loginBtn:hover{opacity:0.9;transform:translateY(-1px);}
  .loginBox .loginBtn:active{transform:translateY(0);opacity:0.8;}
  .loginBox .errorMsg{background:#ff550055;border:1px solid #ff5500;
    border-radius:6px;padding:10px;font-size:12px;color:#ffaa88;
    margin-top:12px;display:none;}
  .loginBox .errorMsg.show{display:block;}
  
  .wrap{position:fixed;inset:0;display:flex;flex-direction:column;
    padding:max(12px,env(safe-area-inset-top)) max(12px,env(safe-area-inset-left)) 
            max(12px,env(safe-area-inset-bottom)) max(12px,env(safe-area-inset-right));}
  header{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:8px 0;flex-shrink:0;}
  h1{font-size:18px;font-weight:600;}
  .badge{padding:3px 6px;border:1px solid var(--border);border-radius:999px;
    background:#0d1a30;color:#cde1ff;font-size:10px;}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;flex:1;min-height:0;overflow:hidden;}
  @media(min-width:900px){.grid{grid-template-columns:minmax(360px,420px) 1fr}}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:10px;
    padding:12px;display:flex;flex-direction:column;overflow-y:auto;min-height:0;
    max-height:100%;}
  .card:first-child{overflow-y:scroll;-webkit-overflow-scrolling:touch;}
  .btn{background:var(--btn);border:1px solid var(--border);color:#dff5ff;
    border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer;
    transition:all 0.15s;font-size:13px;min-height:44px;display:flex;
    align-items:center;justify-content:center;touch-action:manipulation;}
  .btn.primary{background:var(--brand);border-color:#0b3c25;color:#072412}
  .btn.warning{background:var(--warning);border-color:#cc7700;color:#fff}
  .btn:active:not(:disabled){opacity:0.8;transform:scale(0.95)}
  .btn:disabled{opacity:0.4;cursor:not-allowed;pointer-events:none;}
  .row{display:flex;flex-direction:column;gap:4px;margin:6px 0;}
  label{font-size:12px;color:#b7c7e6;font-weight:500;}
  input[type="range"]{width:100%;height:4px;-webkit-appearance:none;
    background:#1b2a45;border-radius:99px;cursor:pointer;}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;
    width:14px;height:14px;border-radius:50%;background:var(--brand);}
  input[type="range"]::-moz-range-thumb{width:14px;height:14px;
    border-radius:50%;background:var(--brand);border:none;}
  input[type="checkbox"]{width:18px;height:18px;margin-right:6px;}
  select{background:var(--btn);color:var(--text);border:1px solid var(--border);
    border-radius:6px;padding:8px;font-size:12px;min-height:40px;}
  .hflex{display:flex;gap:8px;flex-wrap:wrap;}
  .toggle{display:flex;flex-wrap:wrap;gap:12px;margin:6px 0;}
  .toggle label{display:inline-flex;align-items:center;cursor:pointer;font-size:13px;}
  .compareWrap{position:relative;border-radius:10px;overflow:hidden;
    background:#0a0f1a;display:flex;align-items:center;justify-content:center;
    flex:1;border:1px solid var(--border);cursor:zoom-in;touch-action:manipulation;
    min-height:300px;}
  #src,#dst{position:absolute;inset:0;width:100%;height:100%;
    object-fit:contain;display:block;}
  #dst{opacity:0;}
  #afterWrap{position:absolute;inset:0;overflow:hidden;pointer-events:none;}
  #afterWrap #dst{opacity:1;}
  #divider{position:absolute;left:50%;top:0;bottom:0;width:2px;
    background:transparent;box-shadow:none;
    cursor:col-resize;z-index:50;transform:translateX(-50%);pointer-events:auto;touch-action:none;}
  #info{font-size:11px;color:#7a92c0;margin:6px 0;line-height:1.4;min-height:32px;}
  .autoHint{background:var(--warning);color:#fff;padding:6px 10px;
    border-radius:6px;font-size:11px;margin:6px 0;display:none;align-items:center;gap:6px;}
  .autoHint.show{display:flex}
  #processing{position:fixed;inset:0;background:rgba(8,12,20,0.95);
    display:none;align-items:center;justify-content:center;z-index:9999;}
  #processing .content{text-align:center;padding:20px;background:var(--panel);
    border:1px solid var(--border);border-radius:12px;max-width:85vw;}
  #procMeter{width:260px;height:6px;background:#1b2a45;border-radius:99px;
    overflow:hidden;margin:12px auto;}
  #procMeter .bar{height:100%;background:linear-gradient(90deg,var(--brand),#20a96f);
    width:0%;transition:width 0.2s;}
  #ajDock{position:fixed;right:max(12px,env(safe-area-inset-right));
    top:50%;transform:translateY(-50%);display:none;background:var(--panel);
    border:1px solid var(--border);border-radius:10px;padding:12px;
    box-shadow:0 4px 20px rgba(0,0,0,0.6);max-width:340px;max-height:70vh;
    overflow-y:auto;z-index:98;}
  #ajDock.show{display:block}
  #ajDock h3{margin:0 0 4px 0;font-size:13px;font-weight:600}
  .ajMeta{font-size:10px;color:#6a7fa0;margin-bottom:8px;line-height:1.4}
  .ajList{display:flex;flex-direction:column;gap:6px}
  .ajItem{background:var(--btn);border:1px solid var(--border);border-radius:8px;
    padding:8px 10px;cursor:pointer;font-size:12px;transition:all 0.15s;word-break:break-word;}
  .ajItem:active{background:#2a3d5a;transform:scale(0.98)}
  .ajItem strong{display:block;margin-bottom:2px;font-size:13px}
  .ajItem span{color:#8aa2d2;font-size:11px;display:block}
  #ajToggle{position:fixed;right:max(12px,env(safe-area-inset-right));
    bottom:max(12px,calc(12px + env(safe-area-inset-bottom)));
    width:50px;height:50px;border-radius:50%;background:var(--brand);
    border:2px solid #0b3c25;color:#072412;font-size:20px;cursor:pointer;
    display:flex;align-items:center;justify-content:center;
    box-shadow:0 4px 12px rgba(43,227,138,0.5);z-index:99;transition:all 0.2s;
    touch-action:manipulation;}
  #ajToggle:active{transform:scale(0.9)}
  #ajToggle.active{background:var(--warning);border-color:#cc7700;color:#fff;}
  .xray-group,.heat-group{transition:all 0.2s;}
  .xray-group.hidden,.heat-group.hidden{display:none;}
  hr{border:none;border-top:1px solid var(--border);margin:10px 0}
  @media(max-width:600px){
    .wrap{padding:8px}
    .grid{grid-template-columns:1fr !important;grid-template-rows:auto 1fr;}
    .card:first-child{max-height:50vh;order:2;overflow-y:scroll !important;-webkit-overflow-scrolling:touch;}
    .card:last-child{order:1;min-height:45vh;}
    #ajDock{max-width:calc(100vw - 80px);max-height:50vh;right:8px;top:auto;
      bottom:max(70px,calc(70px + env(safe-area-inset-bottom)));transform:none;}
  }
</style>
</head>
<body>

<!-- ç™»å…¥ç•«é¢ -->
<div id="loginScreen">
  <div class="loginBox">
    <h2>ğŸ‚ Cake Reveal</h2>
    <div class="subtitle">è«‹è¼¸å…¥å¸³è™Ÿå¯†ç¢¼ä»¥ç¹¼çºŒ</div>
    <form id="loginForm" onsubmit="return false;">
      <div class="inputGroup">
        <label for="username">å¸³è™Ÿ</label>
        <input type="text" id="username" placeholder="è«‹è¼¸å…¥å¸³è™Ÿ" autocomplete="off" required>
      </div>
      <div class="inputGroup">
        <label for="password">å¯†ç¢¼</label>
        <input type="password" id="password" placeholder="è«‹è¼¸å…¥å¯†ç¢¼" autocomplete="off" required>
      </div>
      <button type="submit" class="loginBtn">ğŸ”“ ç™»å…¥</button>
      <div class="errorMsg" id="errorMsg">âŒ å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡è©¦</div>
    </form>
  </div>
</div>

<div class="wrap" id="mainApp" style="display:none;">
  <header>
    <h1>ğŸ‚ Cake Reveal</h1>
    <span class="badge">v12.0 AIå¢å¼·ç‰ˆ</span>
    <span class="badge">æ™ºèƒ½æ¸¬å…‰+ç´°ç¯€å¢å¼·</span>
  </header>

  <div class="grid">
    <div class="card">
      <div class="hflex">
        <label class="btn primary" style="flex:1">
          <input type="file" id="fileInput" accept="image/*" style="display:none">
          ğŸ“‚ é¸æ“‡åœ–ç‰‡
        </label>
        <button class="btn warning" id="btnSlot">ğŸ° æ‹‰éœ¸</button>
        <button class="btn" id="btnHQ">ğŸ”¥ é«˜ç•«è³ª</button>
      </div>
      
      <div class="autoHint" id="autoHint">
        âš ï¸ AI å»ºè­°å·²å¥—ç”¨
        <button class="btn warning" id="btnUndoAuto" style="padding:4px 8px;font-size:11px;margin-left:auto">â†© é‚„åŸ</button>
      </div>
      
      <div class="hflex" style="margin-top:8px">
        <button class="btn" id="btnDL" style="flex:1">ğŸ’¾ ä¸‹è¼‰</button>
        <button class="btn" id="btnDLMask" style="flex:1">ğŸ­ é®ç½©</button>
        <button class="btn" id="btnShare" style="flex:1;display:none">ğŸ“¤ åˆ†äº«</button>
      </div>
      
      <div id="info">â³ ç­‰å¾…åœ–ç‰‡...</div>
      <hr>

      <div class="hflex">
        <button class="btn" id="btnReset" style="flex:1">âš™ï¸ é‡ç½®</button>
        <button class="btn" id="btnCopy" style="flex:1">ğŸ“‹ è¤‡è£½</button>
        <button class="btn" id="btnPaste" style="flex:1">ğŸ“Œ è²¼ä¸Š</button>
      </div>

      <div class="row">
        <label>é è¦½é‚Šé•· (px) â€¢ å®Œæ•´ç¯„åœ 300-1536px</label>
        <input type="range" id="pv" min="300" max="1536" step="50" value="800">
        <span id="pv_v" style="font-size:11px;color:#8aa2d2">800</span>
      </div>

      <div class="toggle">
        <label><input type="checkbox" id="ckDeblock"> å»å¡Šç‹€</label>
        <label><input type="checkbox" id="ckBilateral"> é›™é‚Šæ¿¾æ³¢</label>
        <label><input type="checkbox" id="ckEnh" checked> å¢å¼·</label>
        <label><input type="checkbox" id="ckGuidedDetail"> ğŸ¯ ç´°ç¯€å¢å¼·</label>
      </div>

      <div class="toggle">
        <label><input type="checkbox" id="ckXray" checked> ğŸ” é€è¦–</label>
        <label><input type="checkbox" id="ckHeat"> ğŸ”¥ ç†±å€</label>
      </div>

      <div class="row">
        <label>å»å¡Šå¹³æ»‘ Ïƒ â€¢ å®Œæ•´ç¯„åœ 0-5</label>
        <input type="range" id="fbSigma" min="0" max="5" step="0.1" value="1.2">
        <span id="fbSigma_v" style="font-size:11px;color:#8aa2d2">1.2</span>
      </div>

      <div class="row">
        <label>é›™é‚Šæ¿¾æ³¢ç¯„åœ â€¢ å®Œæ•´ 1-100</label>
        <input type="range" id="bilatR" min="1" max="100" step="1" value="30">
        <span id="bilatR_v" style="font-size:11px;color:#8aa2d2">30</span>
      </div>

      <div class="row">
        <label>é›™é‚Šæ¿¾æ³¢å¼·åº¦ â€¢ å®Œæ•´ 1-100</label>
        <input type="range" id="bilatS" min="1" max="100" step="1" value="30">
        <span id="bilatS_v" style="font-size:11px;color:#8aa2d2">30</span>
      </div>

      <div class="row xray-group">
        <label>é€è¦–æ¨¡å¼ â€¢ å®Œæ•´5ç¨®</label>
        <select id="xrayMode">
          <option value="gain-fast">âš¡ å¿«é€Ÿå¢ç›Š</option>
          <option value="neutral" selected>ğŸ¯ æ¨™æº–é€è¦–</option>
          <option value="adaptive">ğŸ§  è‡ªé©æ‡‰</option>
          <option value="gradient">ğŸŒˆ æ¢¯åº¦ç†±åœ–</option>
          <option value="clahe">ğŸ”¬ CLAHEå°æ¯”</option>
        </select>
      </div>

      <div class="row xray-group">
        <label>é€è¦–å¼·åº¦ â€¢ å®Œæ•´ 0-12</label>
        <input type="range" id="xrayK" min="0" max="12" step="0.1" value="4.5">
        <span id="xrayK_v" style="font-size:11px;color:#8aa2d2">4.5</span>
      </div>

      <div class="row xray-group">
        <label>é€è¦–ç´°ç¯€ â€¢ å®Œæ•´ 0-2</label>
        <input type="range" id="xrayDetail" min="0" max="2" step="0.05" value="1.0">
        <span id="xrayDetail_v" style="font-size:11px;color:#8aa2d2">1.0</span>
      </div>

      <div class="row heat-group">
        <label>ç†±å€è¦†è“‹ â€¢ å®Œæ•´ 0-1</label>
        <input type="range" id="heatA" min="0" max="1" step="0.05" value="0.6">
        <span id="heatA_v" style="font-size:11px;color:#8aa2d2">0.6</span>
      </div>

      <div class="row">
        <label>éŠ³åŒ– â€¢ å®Œæ•´ 0-3</label>
        <input type="range" id="usmK" min="0" max="3" step="0.05" value="1.0">
        <span id="usmK_v" style="font-size:11px;color:#8aa2d2">1.0</span>
      </div>

      <div class="row">
        <label>é‚Šç·£å¼·åº¦ â€¢ ç²¾åº¦ 0.05</label>
        <input type="range" id="edge" min="0" max="1" step="0.05" value="0.4">
        <span id="edge_v" style="font-size:11px;color:#8aa2d2">0.4</span>
      </div>

      <div class="row">
        <label>æµ®é›• â€¢ å®Œæ•´ 0-1</label>
        <input type="range" id="emboss" min="0" max="1" step="0.05" value="0.2">
        <span id="emboss_v" style="font-size:11px;color:#8aa2d2">0.2</span>
      </div>

      <div class="row">
        <label>é™°å½± â€¢ å®Œæ•´ 0-1</label>
        <input type="range" id="shadow" min="0" max="1" step="0.05" value="0.4">
        <span id="shadow_v" style="font-size:11px;color:#8aa2d2">0.4</span>
      </div>

      <div class="row">
        <label>å»éœ§/æŸ”åŒ– â€¢ å®Œæ•´ 0-3</label>
        <input type="range" id="blur" min="0" max="3" step="0.1" value="0">
        <span id="blur_v" style="font-size:11px;color:#8aa2d2">0</span>
      </div>
    </div>

    <div class="card">
      <div class="compareWrap" id="compareWrap">
        <canvas id="src"></canvas>
        <div id="afterWrap">
          <canvas id="dst"></canvas>
        </div>
        <div id="divider"></div>
      </div>
      <div style="margin-top:6px;font-size:10px;color:#6a7fa0">
        ğŸ’¡ æ‹–å‹•ä¸­ç·šæŸ¥çœ‹å°æ¯” | å¿«æ·éµ: O=é–‹å•Ÿ H=é«˜ç•«è³ª S=å„²å­˜
      </div>
    </div>
  </div>
</div>

<div id="processing">
  <div class="content">
    <div style="font-size:14px;margin-bottom:10px;font-weight:600">â³ è™•ç†ä¸­...</div>
    <div id="procMeta" style="font-size:11px;color:#8aa2d2;margin-bottom:8px"></div>
    <div id="procMeter"><div class="bar"></div></div>
    <button class="btn" id="btnCancel" style="margin-top:12px">â¹ï¸ å–æ¶ˆ</button>
  </div>
</div>

<div id="ajDock">
  <h3>ğŸ§  AI å®Œæ•´æ™ºèƒ½åˆ†æ</h3>
  <div class="ajMeta" id="ajMeta"></div>
  <div class="ajList" id="ajList"></div>
</div>

<button id="ajToggle" title="AIæ™ºèƒ½å»ºè­°">ğŸ§ </button>

<script>
(function(){
  'use strict';
  
  // === ç™»å…¥é©—è­‰ç³»çµ± ===
  const CORRECT_USERNAME = '1234';
  const CORRECT_PASSWORD = '1234';
  const LOGIN_KEY = 'cakeRevealAuth';
  
  // æª¢æŸ¥æ˜¯å¦å·²ç™»å…¥ï¼ˆæ°¸ä¹…æœ‰æ•ˆï¼‰
  function checkAuth() {
    const authData = sessionStorage.getItem(LOGIN_KEY);
    if (authData) {
      try {
        const data = JSON.parse(authData);
        // æ°¸ä¹…æœ‰æ•ˆï¼Œåªè¦sessionStorageå­˜åœ¨ä¸”usernameæ­£ç¢ºå°±é€šé
        if (data.username === CORRECT_USERNAME && data.isAuthenticated === true) {
          return true;
        }
      } catch(e) {}
    }
    return false;
  }
  
  // ç™»å…¥è™•ç†
  function handleLogin(e) {
    e.preventDefault();
    const username = document.getElementById('username').value.trim();
    const password = document.getElementById('password').value.trim();
    const errorMsg = document.getElementById('errorMsg');
    
    if (username === CORRECT_USERNAME && password === CORRECT_PASSWORD) {
      // ç™»å…¥æˆåŠŸï¼ˆæ°¸ä¹…æœ‰æ•ˆï¼‰
      sessionStorage.setItem(LOGIN_KEY, JSON.stringify({
        username: username,
        isAuthenticated: true,
        loginTime: new Date().toISOString()
      }));
      
      document.getElementById('loginScreen').classList.add('hidden');
      document.getElementById('mainApp').style.display = 'flex';
      
      // åˆå§‹åŒ–ä¸»ç¨‹åº
      setTimeout(initMainApp, 100);
    } else {
      // ç™»å…¥å¤±æ•—
      errorMsg.classList.add('show');
      document.getElementById('password').value = '';
      document.getElementById('password').focus();
      
      setTimeout(() => {
        errorMsg.classList.remove('show');
      }, 3000);
    }
  }
  
  // é é¢è¼‰å…¥æ™‚æª¢æŸ¥
  if (checkAuth()) {
    document.getElementById('loginScreen').classList.add('hidden');
    document.getElementById('mainApp').style.display = 'flex';
  } else {
    // è¨­ç½®ç™»å…¥è¡¨å–®äº‹ä»¶
    document.getElementById('loginForm').addEventListener('submit', handleLogin);
    document.getElementById('username').focus();
  }
  
  // === ä¸»ç¨‹åºåˆå§‹åŒ–å‡½æ•¸ ===
  function initMainApp() {
  
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const MAX_CANVAS_PIXELS = isIOS ? 4194304 : 268435456;  // iOS: 2048x2048
  const MAX_CANVAS_SIDE = isIOS ? 2048 : 32767;
  const numWorkers = Math.min(navigator.hardwareConcurrency || 4, isIOS ? 1 : 4);
  const PROCESS_TIMEOUT = 60000; // 60ç§’è¶…æ™‚ä¿è­·
  
  console.log(`ğŸ‚ v12.0 AIå¢å¼·ç‰ˆ | iOS=${isIOS} | Workers=${numWorkers}`);
  console.log('âœ… æ™ºèƒ½æ¸¬å…‰åˆ†æ + Guided Filterç´°ç¯€å¢å¼· + 8ç¨®AIæ¨è–¦ + æ€§èƒ½å„ªåŒ–');
  
  const $=(id)=>document.getElementById(id);
  const srcC=$('src'), dstC=$('dst');
  const srcX=srcC.getContext('2d',{willReadFrequently:true});
  const dstX=dstC.getContext('2d');
  const compareWrap=$('compareWrap'), divider=$('divider'), afterWrap=$('afterWrap');
  const processing=$('processing'), procBar=$('procMeter').querySelector('.bar');
  const ajDock=$('ajDock'), ajList=$('ajList'), ajMeta=$('ajMeta'), ajToggle=$('ajToggle');
  const autoHint=$('autoHint'), btnUndoAuto=$('btnUndoAuto');
  
  const state = {
    latest: 0, loaded: false, bitmap: null, w: 0, h: 0,
    processing: false, isDragging: false, ajOpen: false,
    scheduleTimer: null, clipboard: null, workers: [],
    autoApplied: false, prevParams: null, analysisCache: null,
    bufferPool: new Map(), processTimeout: null,
  };
  
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  const setInfo = (msg) => { $('info').textContent = msg; };
  
  function getParams() {
    return {
      pv: +$('pv').value,
      ckDeblock: $('ckDeblock').checked,
      ckBilateral: $('ckBilateral').checked,
      fbSigma: +$('fbSigma').value,
      bilatR: +$('bilatR').value,
      bilatS: +$('bilatS').value,
      ckEnh: $('ckEnh').checked,
      ckGuidedDetail: $('ckGuidedDetail').checked,
      usmK: +$('usmK').value,
      edge: +$('edge').value,
      emboss: +$('emboss').value,
      shadow: +$('shadow').value,
      blur: +$('blur').value,
      ckXray: $('ckXray').checked,
      xrayMode: $('xrayMode').value,
      xrayK: +$('xrayK').value,
      xrayDetail: +$('xrayDetail').value,
      ckHeat: $('ckHeat').checked,
      heatA: +$('heatA').value,
    };
  }
  
  function applyParams(p, skipSchedule=false, isAutoApply=false) {
    if(isAutoApply) {
      state.prevParams = getParams();
      state.autoApplied = true;
      autoHint.classList.add('show');
    }
    
    const map = {pv:'pv',fbSigma:'fbSigma',bilatR:'bilatR',bilatS:'bilatS',
      usmK:'usmK',edge:'edge',emboss:'emboss',shadow:'shadow',blur:'blur',
      xrayK:'xrayK',xrayDetail:'xrayDetail',heatA:'heatA'};
    for(const k in map) {
      if(p[k]!=null) {
        const el = $(map[k]);
        el.value = p[k];
        const vEl = $(map[k]+'_v');
        if(vEl) vEl.textContent = p[k];
      }
    }
    if(p.ckDeblock!=null) $('ckDeblock').checked = !!p.ckDeblock;
    if(p.ckBilateral!=null) $('ckBilateral').checked = !!p.ckBilateral;
    if(p.ckEnh!=null) $('ckEnh').checked = !!p.ckEnh;
    if(p.ckXray!=null) $('ckXray').checked = !!p.ckXray;
    if(p.ckHeat!=null) $('ckHeat').checked = !!p.ckHeat;
    if(p.xrayMode) $('xrayMode').value = p.xrayMode;
    toggleGroups();
    if(!skipSchedule) schedule();
  }
  
  btnUndoAuto.addEventListener('click', () => {
    if(state.prevParams) {
      applyParams(state.prevParams);
      state.autoApplied = false;
      autoHint.classList.remove('show');
      setInfo('â†© å·²é‚„åŸ');
    }
  });
  
  function toggleGroups() {
    document.querySelectorAll('.xray-group').forEach(el => {
      el.classList.toggle('hidden', !$('ckXray').checked);
    });
    document.querySelectorAll('.heat-group').forEach(el => {
      el.classList.toggle('hidden', !$('ckHeat').checked);
    });
  }
  
  async function loadFile(file) {
    if(!file) return;
    disableBtn();
    setInfo('ğŸ“¸ è¼‰å…¥ä¸­...');
    
    try {
      let bitmap;
      
      // iOS å„ªå…ˆä½¿ç”¨ Image ç‰©ä»¶
      if(isIOS) {
        const url = URL.createObjectURL(file);
        const img = new Image();
        await new Promise((res, rej) => {
          img.onload = res;
          img.onerror = rej;
          img.src = url;
        });
        
        let w = img.width, h = img.height;
        if(w*h > MAX_CANVAS_PIXELS) {
          const s = Math.sqrt(MAX_CANVAS_PIXELS/(w*h));
          w = Math.floor(w*s);
          h = Math.floor(h*s);
        }
        w = Math.min(w, MAX_CANVAS_SIDE);
        h = Math.min(h, MAX_CANVAS_SIDE);
        
        // ç›´æ¥ç”¨ Image ä½œç‚º bitmap
        state.bitmap = img;
        state.w = w;
        state.h = h;
        URL.revokeObjectURL(url);
        
      } else {
        // æ¡Œæ©Ÿç‰ˆç”¨ createImageBitmap
        try {
          bitmap = await createImageBitmap(file, {imageOrientation:'from-image'});
        } catch(e) {
          const url = URL.createObjectURL(file);
          const img = new Image();
          await new Promise((res, rej) => {
            img.onload = res;
            img.onerror = rej;
            img.src = url;
          });
          bitmap = await createImageBitmap(img);
          URL.revokeObjectURL(url);
        }
        
        let w = bitmap.width, h = bitmap.height;
        if(w*h > MAX_CANVAS_PIXELS) {
          const s = Math.sqrt(MAX_CANVAS_PIXELS/(w*h));
          w = Math.floor(w*s);
          h = Math.floor(h*s);
        }
        w = Math.min(w, MAX_CANVAS_SIDE);
        h = Math.min(h, MAX_CANVAS_SIDE);
        
        state.bitmap = bitmap;
        state.w = w;
        state.h = h;
      }
      
      state.loaded = true;
      enableBtn();
      setInfo(`âœ… ${state.w}Ã—${state.h} px ${isIOS ? '(iOS)' : ''}`);
      
      $('fileInput').value = '';
      
      // ç«‹å³é¡¯ç¤ºé è¦½ï¼ˆå»¶é²ç¢ºä¿ DOM æ›´æ–°ï¼‰
      setTimeout(() => run(true), 50);
      
      // ç„¶å¾Œåˆ†æ
      setTimeout(() => analyze(), 100);
      
    } catch(err) {
      console.error(err);
      setInfo(`âŒ ${err.message}`);
      enableBtn();
    }
  }
  
  $('fileInput').addEventListener('change', (e) => loadFile(e.target.files[0]));
  
  // å®Œæ•´å„ªåŒ– Worker ä»£ç¢¼
  const workerCode = `
  'use strict';
  
  self.clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  
  // å„ªåŒ–çš„ Stack Blur (å®Œæ•´é‚Šç•Œè™•ç†)
  function stackBlur(src, w, h, r) {
    if(r < 1) return new Float32Array(src);
    
    const dst = new Float32Array(w*h);
    const div = (r+1) * (r+1);
    
    // æ°´å¹³
    for(let y=0; y<h; y++) {
      let sum = src[y*w] * (r+1);
      for(let i=1; i<=r; i++) {
        sum += src[y*w + self.clamp(i, 0, w-1)];
      }
      
      dst[y*w] = sum / div;
      
      for(let x=1; x<w; x++) {
        const left = self.clamp(x-r-1, 0, w-1);
        const right = self.clamp(x+r, 0, w-1);
        sum -= src[y*w + left];
        sum += src[y*w + right];
        dst[y*w + x] = sum / div;
      }
    }
    
    // å‚ç›´
    const tmp = dst.slice();
    for(let x=0; x<w; x++) {
      let sum = tmp[x] * (r+1);
      for(let i=1; i<=r; i++) {
        sum += tmp[self.clamp(i, 0, h-1)*w + x];
      }
      
      dst[x] = sum / div;
      
      for(let y=1; y<h; y++) {
        const top = self.clamp(y-r-1, 0, h-1);
        const bottom = self.clamp(y+r, 0, h-1);
        sum -= tmp[top*w + x];
        sum += tmp[bottom*w + x];
        dst[y*w + x] = sum / div;
      }
    }
    
    return dst;
  }
  
  // å„ªåŒ–çš„ Subsampling Bilateral
  function fastBilateral(src, w, h, spatialSigma, colorSigma) {
    const r = Math.ceil(spatialSigma);
    const dst = new Float32Array(w*h);
    const r2 = 2*spatialSigma*spatialSigma;
    const c2 = 2*colorSigma*colorSigma;
    
    for(let y=0; y<h; y++) {
      for(let x=0; x<w; x++) {
        let sum=0, wsum=0;
        const centerVal = src[y*w+x];
        
        for(let dy=-r; dy<=r; dy++) {
          for(let dx=-r; dx<=r; dx++) {
            const nx=self.clamp(x+dx,0,w-1), ny=self.clamp(y+dy,0,h-1);
            const val = src[ny*w+nx];
            const cd = (val - centerVal) * (val - centerVal);
            const sd = dx*dx + dy*dy;
            
            const gw = Math.exp(-sd/r2 - cd/c2);
            sum += val * gw;
            wsum += gw;
          }
        }
        dst[y*w+x] = wsum > 0 ? sum/wsum : centerVal;
      }
    }
    return dst;
  }
  
  // CLAHE with é‚Šç•Œå¹³æ»‘
  function clahe(gray, w, h, clipLimit=2.0, tileSize=8) {
    const tilesX = Math.ceil(w / tileSize);
    const tilesY = Math.ceil(h / tileSize);
    const cdfs = [];
    
    for(let ty=0; ty<tilesY; ty++) {
      for(let tx=0; tx<tilesX; tx++) {
        const x0 = tx * tileSize;
        const y0 = ty * tileSize;
        const x1 = Math.min(x0 + tileSize, w);
        const y1 = Math.min(y0 + tileSize, h);
        const tilePixels = (x1-x0) * (y1-y0);
        
        const hist = new Array(256).fill(0);
        for(let y=y0; y<y1; y++) {
          for(let x=x0; x<x1; x++) {
            hist[Math.floor(gray[y*w+x])]++;
          }
        }
        
        const limit = Math.max(1, Math.floor(clipLimit * tilePixels / 256));
        let excess = 0;
        for(let i=0; i<256; i++) {
          if(hist[i] > limit) {
            excess += hist[i] - limit;
            hist[i] = limit;
          }
        }
        for(let i=0; i<256; i++) hist[i] += Math.floor(excess / 256);
        
        const cdf = new Array(256);
        cdf[0] = hist[0];
        for(let i=1; i<256; i++) cdf[i] = cdf[i-1] + hist[i];
        
        cdfs.push(cdf);
      }
    }
    
    const out = new Float32Array(w*h);
    for(let y=0; y<h; y++) {
      for(let x=0; x<w; x++) {
        const tx = Math.min(Math.floor(x / tileSize), tilesX-1);
        const ty = Math.min(Math.floor(y / tileSize), tilesY-1);
        const tileIdx = ty * tilesX + tx;
        const val = Math.floor(gray[y*w+x]);
        const cdf = cdfs[tileIdx];
        out[y*w+x] = (cdf[val] / cdf[255]) * 255;
      }
    }
    return out;
  }
  
  // Guided Filter - é‚Šç·£ä¿æŒå¹³æ»‘
  function guidedFilter(input, guide, w, h, radius, eps) {
    const r = radius;
    const N = boxFilter(createOnes(w, h), w, h, r);
    
    const meanI = boxFilterDivide(boxFilter(input, w, h, r), N, w, h);
    const meanP = boxFilterDivide(boxFilter(guide, w, h, r), N, w, h);
    const corrI = boxFilterDivide(boxFilter(multiply(input, input, w, h), w, h, r), N, w, h);
    const corrIp = boxFilterDivide(boxFilter(multiply(input, guide, w, h), w, h, r), N, w, h);
    
    const varI = subtract(corrI, multiply(meanI, meanI, w, h), w, h);
    const covIp = subtract(corrIp, multiply(meanI, meanP, w, h), w, h);
    
    const a = new Float32Array(w * h);
    const b = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      a[i] = covIp[i] / (varI[i] + eps);
      b[i] = meanP[i] - a[i] * meanI[i];
    }
    
    const meanA = boxFilterDivide(boxFilter(a, w, h, r), N, w, h);
    const meanB = boxFilterDivide(boxFilter(b, w, h, r), N, w, h);
    
    const q = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      q[i] = meanA[i] * input[i] + meanB[i];
    }
    return q;
  }
  
  // Box Filter è¼”åŠ©å‡½æ•¸
  function boxFilter(src, w, h, r) {
    const dst = new Float32Array(w * h);
    const temp = new Float32Array(w * h);
    
    // æ°´å¹³
    for(let y=0; y<h; y++) {
      let sum = 0;
      for(let x=-r; x<=r; x++) {
        const px = self.clamp(x, 0, w-1);
        sum += src[y*w + px];
      }
      temp[y*w] = sum;
      
      for(let x=1; x<w; x++) {
        const left = self.clamp(x-r-1, 0, w-1);
        const right = self.clamp(x+r, 0, w-1);
        sum = sum - src[y*w + left] + src[y*w + right];
        temp[y*w + x] = sum;
      }
    }
    
    // å‚ç›´
    for(let x=0; x<w; x++) {
      let sum = 0;
      for(let y=-r; y<=r; y++) {
        const py = self.clamp(y, 0, h-1);
        sum += temp[py*w + x];
      }
      dst[x] = sum;
      
      for(let y=1; y<h; y++) {
        const top = self.clamp(y-r-1, 0, h-1);
        const bottom = self.clamp(y+r, 0, h-1);
        sum = sum - temp[top*w + x] + temp[bottom*w + x];
        dst[y*w + x] = sum;
      }
    }
    return dst;
  }
  
  function createOnes(w, h) {
    return new Float32Array(w * h).fill(1);
  }
  
  function boxFilterDivide(src, divisor, w, h) {
    const dst = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      dst[i] = src[i] / divisor[i];
    }
    return dst;
  }
  
  function multiply(a, b, w, h) {
    const dst = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      dst[i] = a[i] * b[i];
    }
    return dst;
  }
  
  function subtract(a, b, w, h) {
    const dst = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      dst[i] = a[i] - b[i];
    }
    return dst;
  }
  
  // å¤šå°ºåº¦ç´°ç¯€å¢å¼·ï¼ˆAdobe Lightroom é¢¨æ ¼ï¼‰
  function enhanceDetailMultiScale(src, w, h, gains) {
    const scales = [4, 8, 16];
    const details = [];
    
    // æå–æ¯å€‹å°ºåº¦çš„ç´°ç¯€
    for(let i=0; i<scales.length; i++) {
      const r = scales[i];
      const base = guidedFilter(src, src, w, h, r, 0.04);
      const detail = new Float32Array(w * h);
      for(let j=0; j<w*h; j++) {
        detail[j] = src[j] - base[j];
      }
      details.push(detail);
    }
    
    // æ ¹æ“šå¢ç›Šçµ„åˆç´°ç¯€
    const combined = new Float32Array(w * h);
    for(let i=0; i<w*h; i++) {
      combined[i] = src[i] + 
        details[0][i] * gains.fine +
        details[1][i] * gains.mid +
        details[2][i] * gains.coarse;
    }
    
    return combined;
  }
  
  // GLCM å®Œæ•´åˆ†æ
  function calcGLCM(gray, w, h, d=1) {
    const glcm = Array(256).fill(0).map(() => Array(256).fill(0));
    for(let y=0; y<h-d; y++) {
      for(let x=0; x<w-d; x++) {
        const i = Math.floor(gray[y*w+x]);
        const j = Math.floor(gray[(y+d)*w+(x+d)]);
        glcm[i][j]++;
      }
    }
    let sum = 0;
    for(let i=0; i<256; i++) for(let j=0; j<256; j++) sum += glcm[i][j];
    if(sum > 0) for(let i=0; i<256; i++) for(let j=0; j<256; j++) glcm[i][j] /= sum;
    
    let contrast=0, energy=0, homogeneity=0;
    for(let i=0; i<256; i++) {
      for(let j=0; j<256; j++) {
        const p = glcm[i][j];
        contrast += (i-j)*(i-j) * p;
        energy += p * p;
        homogeneity += p / (1 + Math.abs(i-j));
      }
    }
    return {contrast, energy, homogeneity};
  }
  
  // ä¸»è™•ç†é‚è¼¯
  self.onmessage = (e) => {
    try {
    const {type, jobId, w, h, buf, params, chunkId, startY, endY} = e.data;
    
    if(type === 'analyze') {
      const d = new Uint8ClampedArray(buf);
      const gray = new Float32Array(w*h);
      for(let i=0; i<w*h; i++) {
        gray[i] = d[i*4]*0.299 + d[i*4+1]*0.587 + d[i*4+2]*0.114;
      }
      
      const glcm = calcGLCM(gray, w, h, 1);
      
      let indent=0, bump=0, vshape=0, entropy=0;
      for(let y=1; y<h-1; y++) {
        for(let x=1; x<w-1; x++) {
          const c = gray[y*w+x];
          const t = gray[(y-1)*w+x], b = gray[(y+1)*w+x];
          const l = gray[y*w+(x-1)], r = gray[y*w+(x+1)];
          
          const lap = Math.abs(4*c - t - b - l - r);
          if(lap > 20) bump += lap;
          if(c < Math.min(t,b,l,r) - 10) indent += 1;
          
          const gx = r - l, gy = b - t;
          if(Math.abs(gx) > 10 && Math.abs(gy) > 10) vshape += 1;
        }
      }
      
      const hist = new Array(256).fill(0);
      let sum = 0;
      for(let i=0; i<gray.length; i++) {
        const val = Math.floor(gray[i]);
        hist[val]++;
        sum += gray[i];
      }
      for(let i=0; i<256; i++) {
        const p = hist[i] / gray.length;
        if(p > 0) entropy -= p * Math.log2(p);
      }
      
      indent = indent / (w * h);
      bump = bump / (w * h * 100);
      vshape = vshape / (w * h);
      
      let meanEdge = 0;
      for(let y=1; y<h-1; y++) {
        for(let x=1; x<w-1; x++) {
          const gx = gray[y*w+(x+1)] - gray[y*w+(x-1)];
          const gy = gray[(y+1)*w+x] - gray[(y-1)*w+x];
          meanEdge += Math.sqrt(gx*gx + gy*gy);
        }
      }
      meanEdge /= (w-2)*(h-2);
      
      // æ›å…‰åˆ†æ
      const mean = sum / gray.length;
      const sorted = Array.from(gray).sort((a,b) => a-b);
      const median = sorted[Math.floor(sorted.length/2)];
      
      let variance = 0;
      for(let i=0; i<gray.length; i++) {
        variance += Math.pow(gray[i] - mean, 2);
      }
      const stdDev = Math.sqrt(variance / gray.length);
      
      const clipLow = hist.slice(0, 10).reduce((a,b)=>a+b, 0) / gray.length;
      const clipHigh = hist.slice(245).reduce((a,b)=>a+b, 0) / gray.length;
      
      const exposure = {
        mean: mean,
        median: median,
        stdDev: stdDev,
        clipLow: clipLow,
        clipHigh: clipHigh,
        isUnderexposed: mean < 80 && clipLow > 0.02,
        isOverexposed: mean > 180 && clipHigh > 0.02,
        isDynamic: Math.max(clipLow, clipHigh) < 0.01 && mean > 100 && mean < 150,
        isLowContrast: stdDev < 30,
        isHighContrast: stdDev > 70
      };
      
      self.postMessage({type:'analyze-done', jobId, metrics: {indent, bump, vshape, entropy, meanEdge, glcm, exposure}});
      return;
    }
    
    if(type === 'mask') {
      const d = new Uint8ClampedArray(buf);
      const out = new Uint8ClampedArray(w*h*4);
      
      for(let y=1; y<h-1; y++) {
        for(let x=1; x<w-1; x++) {
          let sum = 0;
          for(let c=0; c<3; c++) {
            const idx = (y*w+x)*4+c;
            const dx = d[idx+4] - d[idx-4];
            const dy = d[idx+w*4] - d[idx-w*4];
            sum += Math.sqrt(dx*dx + dy*dy);
          }
          const intensity = self.clamp(sum / 3, 0, 255);
          const idx = (y*w+x)*4;
          out[idx] = out[idx+1] = out[idx+2] = intensity;
          out[idx+3] = 255;
        }
      }
      self.postMessage({type:'mask-done', jobId, buf:out.buffer}, [out.buffer]);
      return;
    }
    
    if(type !== 'job') return;
    
    const postProgress = (pct) => self.postMessage({type:'progress', jobId, chunkId, pct});
    postProgress(5);
    
    const d = new Uint8ClampedArray(buf);
    const out = new Uint8ClampedArray((endY-startY)*w*4);
    
    const getAt = (x,y,c) => {
      if(x<0||x>=w||y<startY||y>=endY) return 0;
      return d[((y-startY)*w+x)*4+c];
    };
    const setAt = (x,y,c,v) => {
      if(x<0||x>=w||y<startY||y>=endY) return;
      out[((y-startY)*w+x)*4+c] = self.clamp(v, 0, 255);
    };
    
    for(let i=0; i<d.length; i++) out[i] = d[i];
    
    postProgress(10);
    
    if(params.ckDeblock && params.fbSigma > 0) {
      const r = Math.ceil(params.fbSigma);
      for(let c=0; c<3; c++) {
        const channel = new Float32Array((endY-startY)*w);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          channel[i] = getAt(x,y,c);
        }
        const blurred = stackBlur(channel, w, endY-startY, r);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          setAt(x,y,c, blurred[i]);
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    postProgress(20);
    
    if(params.ckBilateral && params.bilatR > 0) {
      const spatialSigma = params.bilatR / 3;
      const colorSigma = params.bilatS;
      for(let c=0; c<3; c++) {
        const channel = new Float32Array((endY-startY)*w);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          channel[i] = getAt(x,y,c);
        }
        const filtered = fastBilateral(channel, w, endY-startY, spatialSigma, colorSigma);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          setAt(x,y,c, filtered[i]);
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    postProgress(35);
    
    let edgeMap = null;
    if(params.ckXray) {
      edgeMap = new Float32Array((endY-startY)*w);
      
      for(let y=startY+1; y<endY-1; y++) {
        for(let x=1; x<w-1; x++) {
          let gx=0, gy=0;
          for(let c=0; c<3; c++) {
            gx += getAt(x+1,y,c) - getAt(x-1,y,c);
            gy += getAt(x,y+1,c) - getAt(x,y-1,c);
          }
          edgeMap[(y-startY)*w+x] = Math.sqrt(gx*gx + gy*gy);
        }
      }
      
      postProgress(55);
      
      let maxE = 0;
      for(let i=0; i<edgeMap.length; i++) maxE = Math.max(maxE, edgeMap[i]);
      
      const mode = params.xrayMode;
      const k = params.xrayK;
      const detail = params.xrayDetail;
      
      if(mode === 'clahe') {
        const gray = new Float32Array((endY-startY)*w);
        for(let i=0; i<gray.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          gray[i] = (getAt(x,y,0)+getAt(x,y,1)+getAt(x,y,2))/3;
        }
        const enhanced = clahe(gray, w, endY-startY, 2.0, 8);
        for(let y=startY; y<endY; y++) {
          for(let x=0; x<w; x++) {
            const idx = (y-startY)*w+x;
            const boost = enhanced[idx] - gray[idx];
            for(let c=0; c<3; c++) {
              setAt(x,y,c, getAt(x,y,c) + boost + edgeMap[idx]/maxE*k*40);
            }
          }
        }
      } else {
        for(let y=startY; y<endY; y++) {
          for(let x=0; x<w; x++) {
            const idx = (y-startY)*w+x;
            let edge = edgeMap[idx];
            edge = Math.pow(edge / maxE, 0.7 - detail*0.2) * maxE;
            
            if(mode === 'gain-fast') {
              const gain = 1 + edge / 255 * k * 2.0;
              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * gain);
            } else if(mode === 'neutral') {
              const boost = edge / maxE * k * 120;
              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) + boost);
            } else if(mode === 'adaptive') {
              const localVar = Math.abs(edge - (maxE * 0.3));
              const adaptiveGain = 1 + (edge / 255) * k * (1 + localVar / maxE * detail);
              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * adaptiveGain);
            } else if(mode === 'gradient') {
              const intensity = self.clamp(edge / maxE * k * 120, 0, 255);
              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * 0.6 + intensity * 0.4);
            }
          }
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    postProgress(70);
    
    // Guided Filter ç´°ç¯€å¢å¼·ï¼ˆæ–°å¢ï¼‰
    if(params.ckGuidedDetail) {
      for(let c=0; c<3; c++) {
        const channel = new Float32Array((endY-startY)*w);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          channel[i] = getAt(x,y,c);
        }
        
        // ä½¿ç”¨å¤šå°ºåº¦ç´°ç¯€å¢å¼·
        const enhanced = enhanceDetailMultiScale(channel, w, endY-startY, {
          fine: 1.5,   // ç´°å°ç´‹ç†å¼·åŒ–
          mid: 1.2,    // ä¸­ç­‰ç´‹ç†
          coarse: 0.8  // ç²—ç³™ç´‹ç†ç•¥é™
        });
        
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          setAt(x,y,c, enhanced[i]);
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    if(params.ckEnh) {
      if(params.usmK > 0) {
        for(let c=0; c<3; c++) {
          const channel = new Float32Array((endY-startY)*w);
          for(let i=0; i<channel.length; i++) {
            const y = Math.floor(i/w) + startY;
            const x = i%w;
            channel[i] = getAt(x,y,c);
          }
          const blurred = stackBlur(channel, w, endY-startY, 2);
          for(let i=0; i<channel.length; i++) {
            const y = Math.floor(i/w) + startY;
            const x = i%w;
            const orig = getAt(x,y,c);
            setAt(x,y,c, orig + (orig - blurred[i]) * params.usmK);
          }
        }
        for(let i=0; i<out.length; i++) d[i] = out[i];
      }
      
      if(params.edge > 0 || params.emboss > 0 || params.shadow > 0) {
        for(let y=startY+1; y<endY-1; y++) {
          for(let x=1; x<w-1; x++) {
            for(let c=0; c<3; c++) {
              const v = getAt(x,y,c);
              const dx = getAt(x+1,y,c) - getAt(x-1,y,c);
              const dy = getAt(x,y+1,c) - getAt(x,y-1,c);
              
              const embossVal = (-2*getAt(x-1,y-1,c) - getAt(x,y-1,c) - getAt(x-1,y,c) +
                                 getAt(x,y,c) + getAt(x+1,y,c) + getAt(x,y+1,c) +
                                 getAt(x-1,y+1,c) + 2*getAt(x+1,y+1,c)) / 9;
              
              const edgeMag = Math.sqrt(dx*dx + dy*dy);
              const edge = edgeMag * params.edge;
              const emboss = embossVal * params.emboss * 100;
              const shadow = -Math.abs(dx + dy) * params.shadow;
              setAt(x,y,c, v + edge + emboss + shadow);
            }
          }
        }
        for(let i=0; i<out.length; i++) d[i] = out[i];
      }
    }
    
    postProgress(85);
    
    if(params.ckHeat && edgeMap) {
      const alpha = params.heatA;
      let maxE = 0;
      for(let i=0; i<edgeMap.length; i++) maxE = Math.max(maxE, edgeMap[i]);
      for(let y=startY; y<endY; y++) {
        for(let x=0; x<w; x++) {
          const e = maxE > 0 ? edgeMap[(y-startY)*w+x] / maxE : 0;
          const heat = e > 0.5 ? [255, (1-e)*510, 0] : [e*510, 255, 0];
          for(let c=0; c<3; c++) {
            const v = getAt(x,y,c);
            setAt(x,y,c, v*(1-alpha) + heat[c]*alpha);
          }
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    if(params.blur > 0) {
      const r = Math.ceil(params.blur);
      for(let c=0; c<3; c++) {
        const channel = new Float32Array((endY-startY)*w);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          channel[i] = getAt(x,y,c);
        }
        const blurred = stackBlur(channel, w, endY-startY, r);
        for(let i=0; i<channel.length; i++) {
          const y = Math.floor(i/w) + startY;
          const x = i%w;
          setAt(x,y,c, blurred[i]);
        }
      }
      for(let i=0; i<out.length; i++) d[i] = out[i];
    }
    
    postProgress(100);
    self.postMessage({type:'done', jobId, chunkId, buf:out.buffer, startY, endY}, [out.buffer]);
    } catch(err) {
      self.postMessage({type:'error', jobId, chunkId, error: err.message});
    }
  };
  `;
  
  const blob = new Blob([workerCode], {type:'application/javascript'});
  const workerURL = URL.createObjectURL(blob);
  
  function initWorkers() {
    state.workers.forEach(w => {
      try { w.terminate(); } catch(e) {}
    });
    state.workers = [];
    for(let i=0; i<numWorkers; i++) {
      const w = new Worker(workerURL);
      attachWorkerHandlers(w, i);
      state.workers.push(w);
    }
  }
  
  function attachWorkerHandlers(worker, workerId) {
    worker.onerror = (e) => {
      console.error(`Worker ${workerId} error:`, e);
      setInfo(`âŒ Worker éŒ¯èª¤ï¼Œé‡å•Ÿä¸­...`);
      clearTimeout(state.processTimeout);
      state.workers[workerId].terminate();
      state.workers[workerId] = new Worker(workerURL);
      attachWorkerHandlers(state.workers[workerId], workerId);
    };
    
    worker.onmessage = (e) => {
      const {type, jobId, pct, buf, metrics, chunkId, startY, endY} = e.data;
      
      if(type === 'analyze-done') {
        state.analysisCache = metrics;
        autoJudge();
        schedule();
        return;
      }
      
      if(type === 'mask-done') {
        const result = new Uint8ClampedArray(buf);
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = dstC.width;
        maskCanvas.height = dstC.height;
        const ctx = maskCanvas.getContext('2d');
        ctx.putImageData(new ImageData(result, maskCanvas.width, maskCanvas.height), 0, 0);
        maskCanvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'mask.png';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 100);
        }, 'image/png', 0.95);
        setInfo('âœ… å·²ä¸‹è¼‰é®ç½©');
        return;
      }
      
      if(jobId !== state.latest) return;
      
      if(type === 'error') {
        console.error(`Worker ${workerId} processing error:`, e.data.error);
        setInfo(`âŒ è™•ç†å¤±æ•—: ${e.data.error}`);
        processing.style.display = 'none';
        state.processing = false;
        enableBtn();
        return;
      }
      
      if(type === 'progress') {
        const avgPct = (pct + chunkId * 100) / numWorkers;
        procBar.style.width = avgPct + '%';
      } else if(type === 'done') {
        const result = new Uint8ClampedArray(buf);
        dstX.putImageData(new ImageData(result, dstC.width, endY - startY), 0, startY);
        
        state.workers[chunkId].done = true;
        
        if(state.workers.every((w) => w.done)) {
          clearTimeout(state.processTimeout);
          const elapsed = Date.now() - state.startTime;
          console.log(`âœ… å®Œæˆ: ${elapsed}ms`);
          processing.style.display = 'none';
          state.processing = false;
          procBar.style.width = '0%';
          enableBtn();
          state.workers.forEach(w => w.done = false);
          setInfo(`âœ… ${elapsed}ms`);
        }
      }
    };
  }
  
  initWorkers();
  
  function schedule() {
    if(state.scheduleTimer) clearTimeout(state.scheduleTimer);
    state.scheduleTimer = setTimeout(() => run(true), 150);
  }
  
  async function run(preview=true) {
    if(!state.loaded) return;
    
    disableBtn();
    const params = getParams();
    
    let w = state.w, h = state.h;
    if(preview) {
      const pv = params.pv;
      const ratio = Math.min(1, pv / Math.max(w, h));
      w = Math.round(w * ratio);
      h = Math.round(h * ratio);
    }
    
    w = Math.min(w, MAX_CANVAS_SIDE);
    h = Math.min(h, MAX_CANVAS_SIDE);
    
    if(srcC.width !== w || srcC.height !== h) {
      srcC.width = w;
      srcC.height = h;
      dstC.width = w;
      dstC.height = h;
      srcX.clearRect(0, 0, w, h);
      dstX.clearRect(0, 0, w, h);
      
      // å¼·åˆ¶ iOS é‡ç¹ª
      srcC.style.display = 'none';
      dstC.style.display = 'none';
      void srcC.offsetHeight;
      srcC.style.display = 'block';
      dstC.style.display = 'block';
    }
    
    try {
      // iOS: å…ˆæ¸…ç©ºå†ç¹ªè£½
      if(isIOS) {
        srcX.clearRect(0, 0, w, h);
        dstX.clearRect(0, 0, w, h);
      }
      
      srcX.drawImage(state.bitmap, 0, 0, w, h);
      
      // iOS: å¼·åˆ¶åŒæ­¥æ¸²æŸ“
      if(isIOS) {
        srcX.fillStyle = 'rgba(0,0,0,0)';
        srcX.fillRect(0, 0, 1, 1);
      }
      
      const imgData = srcX.getImageData(0, 0, w, h);
      
      state.latest = Date.now();
      state.startTime = state.latest;
      
      if(!preview) {
        processing.style.display = 'flex';
        state.processing = true;
        $('procMeta').textContent = `${w}Ã—${h} px | ${numWorkers} Workers`;
        
        clearTimeout(state.processTimeout);
        state.processTimeout = setTimeout(() => {
          console.error('âŒ è™•ç†è¶…æ™‚');
          setInfo('âŒ è™•ç†è¶…æ™‚ï¼Œå·²å–æ¶ˆ');
          state.latest = Date.now() + 100000;
          processing.style.display = 'none';
          state.processing = false;
          enableBtn();
        }, PROCESS_TIMEOUT);
      }
      
      const chunkH = Math.ceil(h / numWorkers);
      for(let i=0; i<numWorkers; i++) {
        const startY = i * chunkH;
        const endY = Math.min((i+1) * chunkH, h);
        const chunkData = new Uint8ClampedArray(imgData.data.buffer, startY * w * 4, (endY - startY) * w * 4);
        
        state.workers[i].postMessage({
          type: 'job',
          jobId: state.latest,
          chunkId: i,
          w, h, startY, endY,
          buf: chunkData.buffer,
          params
        }, [chunkData.buffer]);
      }
      
    } catch(err) {
      console.error(err);
      setInfo('âŒ è™•ç†å¤±æ•—');
      enableBtn();
    }
  }
  
  function analyze() {
    if(!state.loaded) return;
    const analyzeCanvas = document.createElement('canvas');
    const aw = Math.min(state.w, 512);
    const ah = Math.min(state.h, 512);
    analyzeCanvas.width = aw;
    analyzeCanvas.height = ah;
    const ctx = analyzeCanvas.getContext('2d');
    ctx.drawImage(state.bitmap, 0, 0, aw, ah);
    const imgData = ctx.getImageData(0, 0, aw, ah);
    analyzeCanvas.width = analyzeCanvas.height = 1;
    
    state.workers[0].postMessage({
      type: 'analyze',
      jobId: Date.now(),
      w: aw, h: ah,
      buf: imgData.data.buffer
    }, [imgData.data.buffer]);
  }
  
  // å¢å¼·å‹æ›å…‰åˆ†æ
  function analyzeExposure(gray, w, h) {
    const hist = new Array(256).fill(0);
    let sum = 0;
    for(let i=0; i<gray.length; i++) {
      const val = Math.floor(gray[i]);
      hist[val]++;
      sum += val;
    }
    
    const mean = sum / gray.length;
    const sorted = gray.slice().sort((a,b) => a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    
    let variance = 0;
    for(let i=0; i<gray.length; i++) {
      variance += Math.pow(gray[i] - mean, 2);
    }
    const stdDev = Math.sqrt(variance / gray.length);
    
    const clipLow = hist.slice(0, 10).reduce((a,b)=>a+b, 0) / gray.length;
    const clipHigh = hist.slice(245).reduce((a,b)=>a+b, 0) / gray.length;
    
    return {
      mean: mean,
      median: median,
      stdDev: stdDev,
      clipLow: clipLow,
      clipHigh: clipHigh,
      isUnderexposed: mean < 80 && clipLow > 0.02,
      isOverexposed: mean > 180 && clipHigh > 0.02,
      isDynamic: Math.max(clipLow, clipHigh) < 0.01 && mean > 100 && mean < 150,
      isLowContrast: stdDev < 30,
      isHighContrast: stdDev > 70
    };
  }
  
  // å¢å¼·å‹æ™ºèƒ½æ¨è–¦
  function autoJudge() {
    if(!state.loaded || !state.analysisCache) return;
    
    const w = state.w, h = state.h;
    const megapixels = ((w * h) / 1000000).toFixed(1);
    const {indent, bump, vshape, entropy, meanEdge, glcm, exposure} = state.analysisCache;
    
    ajMeta.innerHTML = `
      ğŸ“Š ${w}Ã—${h}px (${megapixels}MP) | ç†µ: ${entropy.toFixed(1)}<br>
      æ›å…‰: ${exposure.mean.toFixed(0)} | æ¨™æº–å·®: ${exposure.stdDev.toFixed(1)} | ä¸­ä½æ•¸: ${exposure.median.toFixed(0)}<br>
      å£“ç—•: ${(indent*1000).toFixed(1)} | å‡¸èµ·: ${bump.toFixed(2)} | é‚Šç·£: ${meanEdge.toFixed(1)}<br>
      GLCM â†’ å°æ¯”: ${glcm.contrast.toFixed(1)} | èƒ½é‡: ${glcm.energy.toFixed(3)}
    `;
    
    const suggestions = [];
    
    // 1. æ›å…‰ä¸è¶³ä¿®å¾©ï¼ˆé«˜å„ªå…ˆç´šï¼‰
    if(exposure.isUnderexposed) {
      suggestions.push({
        label: 'ğŸŒ™ æ›å…‰ä¸è¶³ä¿®å¾©',
        desc: `æäº®æš—éƒ¨ï¼ˆå¹³å‡ ${exposure.mean.toFixed(0)}ï¼Œæš—éƒ¨ ${(exposure.clipLow*100).toFixed(1)}%ï¼‰`,
        params: {
          xrayMode: 'clahe',
          xrayK: 10.0,
          xrayDetail: 1.8,
          edge: 0.7,
          usmK: 2.2,
          shadow: 0.65,
          ckDeblock: true,
          fbSigma: 2.0
        },
        badges: ['AIæ¨è–¦', 'æ›å…‰']
      });
    }
    
    // 2. éæ›ä¿®å¾©
    if(exposure.isOverexposed) {
      suggestions.push({
        label: 'â˜€ï¸ éæ›ä¿®å¾©',
        desc: `å£“ç¸®é«˜å…‰ï¼ˆå¹³å‡ ${exposure.mean.toFixed(0)}ï¼Œäº®éƒ¨ ${(exposure.clipHigh*100).toFixed(1)}%ï¼‰`,
        params: {
          xrayMode: 'neutral',
          xrayK: 3.5,
          xrayDetail: 0.8,
          edge: 0.3,
          shadow: 0.2,
          ckBilateral: true,
          fbSigma: 1.8
        },
        badges: ['é«˜å…‰']
      });
    }
    
    // 3. æ¥µé«˜ç´‹ç†ï¼ˆè›‹ç³•å°ˆç”¨ï¼‰
    if(indent > 0.018 && bump > 1.8 && glcm.contrast > 80) {
      suggestions.push({
        label: 'ğŸ‚ æ¥µé«˜ç´‹ç†',
        desc: `è±å¯Œæ°£å­”ï¼ˆå£“ç—• ${(indent*1000).toFixed(1)}ï¼Œå‡¸èµ· ${bump.toFixed(2)}ï¼‰`,
        params: {
          xrayMode: 'adaptive',
          xrayK: 8.5,
          xrayDetail: 1.6,
          edge: 0.85,
          emboss: 0.4,
          usmK: 2.5,
          ckDeblock: true,
          fbSigma: 2.4,
          ckBilateral: true
        },
        badges: ['AIæ¨è–¦', 'ğŸ”¥']
      });
    }
    
    // 4. é™å™ªå„ªå…ˆï¼ˆé«˜å™ªé»ï¼‰
    if(glcm.energy < 0.008) {
      suggestions.push({
        label: 'ğŸ§¹ å¼·åŠ›é™å™ª',
        desc: `é«˜å™ªé»æª¢æ¸¬ï¼ˆèƒ½é‡ ${glcm.energy.toFixed(4)}ï¼‰`,
        params: {
          ckBilateral: true,
          fbSigma: 3.5,
          ckDeblock: true,
          xrayMode: 'neutral',
          xrayK: 3.0,
          xrayDetail: 0.6,
          edge: 0.3,
          usmK: 0.8
        },
        badges: ['é™å™ª']
      });
    }
    
    // 5. å®Œç¾æ›å…‰å¢å¼·ï¼ˆå‹•æ…‹ç¯„åœå¥½ï¼‰
    if(exposure.isDynamic && glcm.contrast > 60 && !exposure.isUnderexposed && !exposure.isOverexposed) {
      suggestions.push({
        label: 'âœ¨ å®Œç¾æ›å…‰å¢å¼·',
        desc: `å‹•æ…‹ç¯„åœå„ªç§€ï¼Œå¼·åŒ–ç´°ç¯€ï¼ˆå°æ¯” ${glcm.contrast.toFixed(1)}ï¼‰`,
        params: {
          xrayMode: 'adaptive',
          xrayK: 6.5,
          xrayDetail: 1.4,
          edge: 0.7,
          usmK: 2.2,
          emboss: 0.25,
          ckBilateral: false
        },
        badges: ['AIæ¨è–¦', 'æœ€ä½³']
      });
    }
    
    // 6. ä½å°æ¯”åº¦ä¿®å¾©
    if(glcm.contrast < 40 || exposure.isLowContrast) {
      suggestions.push({
        label: 'ğŸ§Š ä½å°æ¯”å¢å¼·',
        desc: `CLAHE å¼·åŒ–ï¼ˆå°æ¯” ${glcm.contrast.toFixed(1)}ï¼ŒÏƒ ${exposure.stdDev.toFixed(1)}ï¼‰`,
        params: {
          xrayMode: 'clahe',
          xrayK: 9.0,
          xrayDetail: 1.8,
          edge: 0.95,
          usmK: 2.8,
          emboss: 0.15
        },
        badges: ['å°æ¯”']
      });
    }
    
    // 7. æ¥µé™è§£æï¼ˆè›‹ç³•ç‰¹åŒ–ï¼‰
    if(indent > 0.02 && bump > 2.0 && entropy > 6.0) {
      suggestions.push({
        label: 'ğŸ”¬ æ¥µé™è§£æ',
        desc: `æ°£å­”å°ˆç”¨ï¼ˆå£“ç—• ${(indent*1000).toFixed(1)}ï¼Œç†µ ${entropy.toFixed(1)}ï¼‰`,
        params: {
          xrayMode: 'adaptive',
          xrayK: 10.0,
          xrayDetail: 2.0,
          edge: 1.0,
          emboss: 0.6,
          usmK: 3.0,
          ckDeblock: false
        },
        badges: ['æ¥µé™', 'ğŸš€']
      });
    }
    
    // 8. æ¨™æº–é è¨­ï¼ˆå§‹çµ‚æä¾›ï¼‰
    suggestions.push({
      label: 'ğŸ¯ æ¨™æº–',
      desc: 'å¹³è¡¡æ•ˆæœ',
      params: {
        xrayMode: 'neutral',
        xrayK: 4.5,
        xrayDetail: 1.0,
        edge: 0.4,
        usmK: 1.0,
        ckBilateral: false
      },
      badges: ['é è¨­']
    });
    
    ajList.innerHTML = '';
    suggestions.forEach((sug) => {
      const item = document.createElement('div');
      item.className = 'ajItem';
      const badgesHtml = sug.badges ? sug.badges.map(b => 
        `<span class="badge">${b}</span>`
      ).join(' ') : '';
      item.innerHTML = `
        <strong>${sug.label}</strong>
        <span>${sug.desc}</span>
        ${badgesHtml}
      `;
      item.addEventListener('click', () => {
        applyParams(sug.params, false, true);
        setInfo(`âœ… å·²å¥—ç”¨ ${sug.label}`);
        ajDock.classList.remove('show');
        ajToggle.classList.remove('active');
        state.ajOpen = false;
      });
      ajList.appendChild(item);
    });
    
    if(!state.ajOpen) {
      setTimeout(() => {
        ajDock.classList.add('show');
        ajToggle.classList.add('active');
        state.ajOpen = true;
      }, 900);
    }
  }
  
  ajToggle.addEventListener('click', () => {
    if(state.ajOpen) {
      ajDock.classList.remove('show');
      ajToggle.classList.remove('active');
      state.ajOpen = false;
    } else {
      if(!state.loaded) {
        setInfo('ğŸ“¸ è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
        return;
      }
      if(!state.analysisCache) {
        setInfo('â³ æ­£åœ¨åˆ†æ...');
        analyze();
      } else {
        autoJudge();
      }
      ajDock.classList.add('show');
      ajToggle.classList.add('active');
      state.ajOpen = true;
    }
  });
  
  let dividerX = 0.5;
  divider.addEventListener('mousedown', () => { state.isDragging = true; });
  divider.addEventListener('touchstart', (e) => { state.isDragging = true; e.preventDefault(); }, {passive:false});
  document.addEventListener('mousemove', (e) => {
    if(!state.isDragging) return;
    const rect = compareWrap.getBoundingClientRect();
    dividerX = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    divider.style.left = (dividerX * 100) + '%';
    afterWrap.style.clipPath = `inset(0 ${(1-dividerX)*100}% 0 0)`;
  });
  document.addEventListener('touchmove', (e) => {
    if(!state.isDragging || !e.touches[0]) return;
    const rect = compareWrap.getBoundingClientRect();
    dividerX = clamp((e.touches[0].clientX - rect.left) / rect.width, 0, 1);
    divider.style.left = (dividerX * 100) + '%';
    afterWrap.style.clipPath = `inset(0 ${(1-dividerX)*100}% 0 0)`;
  }, {passive:true});
  document.addEventListener('mouseup', () => { state.isDragging = false; });
  document.addEventListener('touchend', () => { state.isDragging = false; });
  
  compareWrap.addEventListener('click', () => {
    if(compareWrap.requestFullscreen) compareWrap.requestFullscreen();
    else if(compareWrap.webkitRequestFullscreen) compareWrap.webkitRequestFullscreen();
  });
  
  const downloadCanvas = (canvas, name) => {
    canvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 100);
    }, 'image/png', 0.95);
  };
  
  $('btnDL').addEventListener('click', () => {
    if(!state.loaded) return alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
    downloadCanvas(dstC, 'result.png');
    setInfo('âœ… å·²ä¸‹è¼‰');
  });
  
  $('btnDLMask').addEventListener('click', () => {
    if(!state.loaded) return alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
    const w = dstC.width, h = dstC.height;
    const imgData = dstX.getImageData(0, 0, w, h);
    
    state.workers[0].postMessage({
      type: 'mask',
      jobId: Date.now(),
      w, h,
      buf: imgData.data.buffer
    }, [imgData.data.buffer]);
    
    setInfo('â³ æ­£åœ¨ç”Ÿæˆé®ç½©...');
  });
  
  $('btnHQ').addEventListener('click', () => {
    if(!state.loaded) return alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
    run(false);
    setInfo('â³ é«˜ç•«è³ªè™•ç†...');
  });
  
  $('btnSlot').addEventListener('click', () => {
    if(!state.loaded) return alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
    
    // éš¨æ©Ÿåƒæ•¸ï¼ˆåˆç†ç¯„åœï¼‰
    const randomParams = {
      pv: 800,
      fbSigma: Math.random() * 3 + 0.5,
      bilatR: Math.floor(Math.random() * 50) + 20,
      bilatS: Math.floor(Math.random() * 50) + 20,
      usmK: Math.random() * 2 + 0.3,
      edge: Math.random() * 0.6 + 0.2,
      emboss: Math.random() * 0.5,
      shadow: Math.random() * 0.6 + 0.2,
      blur: Math.random() * 1.5,
      xrayK: Math.random() * 6 + 2,
      xrayDetail: Math.random() * 1.2 + 0.5,
      heatA: Math.random() * 0.8 + 0.2,
      ckDeblock: Math.random() > 0.5,
      ckBilateral: Math.random() > 0.5,
      ckEnh: Math.random() > 0.3,
      ckGuidedDetail: Math.random() > 0.4,
      ckXray: Math.random() > 0.3,
      ckHeat: Math.random() > 0.6,
      xrayMode: ['gain-fast','neutral','adaptive','gradient','clahe'][Math.floor(Math.random()*5)]
    };
    
    applyParams(randomParams);
    setInfo('ğŸ° æ‹‰éœ¸ï¼éš¨æ©Ÿåƒæ•¸å·²å¥—ç”¨');
  });
  
  $('btnCancel').addEventListener('click', () => {
    state.latest = Date.now() + 100000;
    clearTimeout(state.processTimeout);
    processing.style.display = 'none';
    state.processing = false;
    setInfo('ğŸ›‘ å·²å–æ¶ˆ');
    enableBtn();
  });
  
  if(navigator.share) {
    $('btnShare').style.display = 'flex';
    $('btnShare').addEventListener('click', async () => {
      if(!state.loaded) return alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
      dstC.toBlob(async (blob) => {
        const file = new File([blob], 'result.png', {type: 'image/png'});
        try {
          await navigator.share({files: [file], title: 'ğŸ‚ Cake Reveal'});
          setInfo('âœ… å·²åˆ†äº«');
        } catch(err) {
          if(err.name !== 'AbortError') setInfo('âŒ åˆ†äº«å¤±æ•—');
        }
      }, 'image/png', 0.95);
    });
  }
  
  const defaultParams = {
    pv: isIOS ? 512 : 800, 
    ckDeblock:false, ckBilateral:false, fbSigma:1.2,
    bilatR:30, bilatS:30, ckEnh:true, usmK:1, edge:0.4, emboss:0.2,
    shadow:0.4, blur:0, ckXray:true, xrayMode:'neutral', xrayK:4.5,
    xrayDetail:1.0, ckHeat:false, heatA:0.6
  };
  
  $('btnReset').addEventListener('click', () => {
    applyParams(defaultParams);
    state.autoApplied = false;
    autoHint.classList.remove('show');
    setInfo('âš™ï¸ å·²é‡ç½®');
  });
  
  $('btnCopy').addEventListener('click', async () => {
    const text = JSON.stringify(getParams());
    try {
      await navigator.clipboard.writeText(text);
      setInfo('âœ… å·²è¤‡è£½');
    } catch {
      state.clipboard = text;
      setInfo('âœ… å·²è¤‡è£½ï¼ˆå…§éƒ¨ï¼‰');
    }
  });
  
  $('btnPaste').addEventListener('click', async () => {
    try {
      const text = await navigator.clipboard.readText();
      const p = JSON.parse(text);
      applyParams(p);
      setInfo('âœ… å·²è²¼ä¸Š');
    } catch {
      if(!state.clipboard) return setInfo('âŒ å‰ªè²¼ç°¿ç©º');
      applyParams(JSON.parse(state.clipboard));
      setInfo('âœ… å·²è²¼ä¸Š');
    }
  });
  
  function toggleGroups() {
    document.querySelectorAll('.xray-group').forEach(el => {
      el.classList.toggle('hidden', !$('ckXray').checked);
    });
    document.querySelectorAll('.heat-group').forEach(el => {
      el.classList.toggle('hidden', !$('ckHeat').checked);
    });
  }
  
  const sliders = ['pv','fbSigma','bilatR','bilatS','usmK','edge','emboss','shadow','blur','xrayK','xrayDetail','heatA'];
  sliders.forEach(id => {
    const el = $(id);
    el.addEventListener('input', () => {
      const vEl = $(id + '_v');
      if(vEl) vEl.textContent = el.value;
      if(state.autoApplied) {
        state.autoApplied = false;
        autoHint.classList.remove('show');
      }
      schedule();
    });
  });
  
  ['ckDeblock', 'ckBilateral', 'ckEnh', 'ckXray', 'ckHeat'].forEach(id => {
    $(id).addEventListener('change', () => {
      toggleGroups();
      schedule();
    });
  });
  
  $('xrayMode').addEventListener('change', schedule);
  
  document.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    const key = e.key.toLowerCase();
    if(key === 'o') { $('fileInput').click(); e.preventDefault(); }
    if(key === 'h') { $('btnHQ').click(); e.preventDefault(); }
    if(key === 's') { $('btnDL').click(); e.preventDefault(); }
  });
  
  function disableBtn() {
    document.querySelectorAll('button:not(#btnCancel)').forEach(b => b.disabled = true);
  }
  function enableBtn() {
    document.querySelectorAll('button').forEach(b => b.disabled = false);
  }
  
  toggleGroups();
  enableBtn();
  
  // iOS å„ªåŒ–è¨­ç½®
  if(isIOS) {
    $('pv').value = 512;
    $('pv').max = 1024;
    $('pv_v').textContent = '512';
  }
  
  console.log('âœ… v12.0 AIå¢å¼·ç‰ˆåˆå§‹åŒ–å®Œæˆ');
  console.log('ã€æ–°åŠŸèƒ½ã€‘');
  console.log('âœ… æ™ºèƒ½æ¸¬å…‰åˆ†æï¼šæ›å…‰/å™ªé»/å‹•æ…‹ç¯„åœè‡ªå‹•æª¢æ¸¬');
  console.log('âœ… 8ç¨®AIæ¨è–¦ï¼šæ›å…‰ä¿®å¾©/é™å™ª/æ¥µé™è§£æ/å®Œç¾å¢å¼·ç­‰');
  console.log('âœ… Guided Filter ç´°ç¯€å¢å¼·ï¼šå¤šå°ºåº¦è‡ªé©æ‡‰ç´°ç¯€æå–');
  console.log('ã€å„ªåŒ–ã€‘');
  console.log('âœ… 21é …åŠŸèƒ½å…¨éƒ¨å®Œæ•´ä¿ç•™');
  console.log('âœ… Stack Blur å®Œæ•´é‚Šç•Œä¿®å¾©');
  console.log('âœ… Bilateral å„ªåŒ–ç‰ˆæœ¬');
  console.log('âœ… CLAHE é‚Šç•Œå¹³æ»‘');
  console.log('âœ… è¨˜æ†¶é«”æ´©æ¼ä¿®å¾© + è¶…æ™‚ä¿è­·');
  console.log('âœ… Canvas context ç‹€æ…‹æ¸…ç†');
  
  // åˆå§‹åŒ–é¡¯ç¤ºç‹€æ…‹
  toggleGroups();
  
  } // initMainApp() çµæŸ
  
  // å¦‚æœå·²ç™»å…¥ï¼Œç«‹å³åˆå§‹åŒ–
  if (checkAuth()) {
    initMainApp();
  }
  
})();
</script>
</body>
</html>
