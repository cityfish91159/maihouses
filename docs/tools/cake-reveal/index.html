<!DOCTYPE html><html lang="zh-Hant"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,maximum-scale=1"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-touch-fullscreen" content="yes"><title>ğŸ‚ Cake Reveal v12.0 - AIå¢å¼·ç‰ˆ (æ™ºèƒ½æ¸¬å…‰+Guided Filterç´°ç¯€+æ€§èƒ½å„ªåŒ–)</title><style>*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}:root{--bg:#0b1220;--panel:#0f1b2e;--text:#e9f0ff;--brand:#2be38a;--border:#1b2a45;--btn:#20314f;--warning:#ff9500}body,html{width:100%;height:100%;background:var(--bg);color:var(--text);font-family:-apple-system,system-ui,sans-serif;overflow:hidden;position:fixed;-webkit-user-select:none;-webkit-font-smoothing:antialiased}#loginScreen{position:fixed;inset:0;background:var(--bg);display:flex;align-items:center;justify-content:center;z-index:10000}#loginScreen.hidden{display:none}.loginBox{background:var(--panel);border:2px solid var(--border);border-radius:16px;padding:32px;max-width:360px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,.6)}.loginBox h2{font-size:24px;margin-bottom:8px;text-align:center;color:var(--brand)}.loginBox .subtitle{font-size:12px;color:#7a92c0;text-align:center;margin-bottom:24px}.loginBox .inputGroup{margin-bottom:16px}.loginBox .inputGroup label{display:block;font-size:12px;color:#b7c7e6;margin-bottom:6px;font-weight:600}.loginBox .inputGroup input{width:100%;background:var(--btn);border:1px solid var(--border);border-radius:8px;padding:12px;color:var(--text);font-size:14px;outline:0;transition:all .2s}.loginBox .inputGroup input:focus{border-color:var(--brand);box-shadow:0 0 0 3px rgba(43,227,138,.1)}.loginBox .loginBtn{width:100%;background:var(--brand);border:none;border-radius:8px;padding:14px;font-weight:700;font-size:14px;color:#072412;cursor:pointer;transition:all .2s;margin-top:8px}.loginBox .loginBtn:hover{opacity:.9;transform:translateY(-1px)}.loginBox .loginBtn:active{transform:translateY(0);opacity:.8}.loginBox .errorMsg{background:#ff550055;border:1px solid #f50;border-radius:6px;padding:10px;font-size:12px;color:#fa8;margin-top:12px;display:none}.loginBox .errorMsg.show{display:block}.wrap{position:fixed;inset:0;display:flex;flex-direction:column;padding:max(12px,env(safe-area-inset-top)) max(12px,env(safe-area-inset-left)) max(12px,env(safe-area-inset-bottom)) max(12px,env(safe-area-inset-right))}header{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:8px 0;flex-shrink:0}h1{font-size:18px;font-weight:600}.badge{padding:3px 6px;border:1px solid var(--border);border-radius:999px;background:#0d1a30;color:#cde1ff;font-size:10px}.grid{display:grid;grid-template-columns:1fr;gap:12px;flex:1;min-height:0;overflow:hidden}@media(min-width:900px){.grid{grid-template-columns:minmax(360px,420px) 1fr}}.card{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;display:flex;flex-direction:column;overflow-y:auto;min-height:0}.btn{background:var(--btn);border:1px solid var(--border);color:#dff5ff;border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer;transition:all .15s;font-size:13px;min-height:44px;display:flex;align-items:center;justify-content:center;touch-action:manipulation}.btn.primary{background:var(--brand);border-color:#0b3c25;color:#072412}.btn.warning{background:var(--warning);border-color:#c70;color:#fff}.btn:active:not(:disabled){opacity:.8;transform:scale(.95)}.btn:disabled{opacity:.4;cursor:not-allowed;pointer-events:none}.row{display:flex;flex-direction:column;gap:4px;margin:6px 0}label{font-size:12px;color:#b7c7e6;font-weight:500}input[type=range]{width:100%;height:4px;-webkit-appearance:none;background:#1b2a45;border-radius:99px;cursor:pointer}input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--brand)}input[type=range]::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--brand);border:none}input[type=checkbox]{width:18px;height:18px;margin-right:6px}select{background:var(--btn);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:8px;font-size:12px;min-height:40px}.hflex{display:flex;gap:8px;flex-wrap:wrap}.toggle{display:flex;flex-wrap:wrap;gap:12px;margin:6px 0}.toggle label{display:inline-flex;align-items:center;cursor:pointer;font-size:13px}.compareWrap{position:relative;border-radius:10px;overflow:hidden;background:#0a0f1a;display:flex;align-items:center;justify-content:center;flex:1;border:1px solid var(--border);cursor:zoom-in;touch-action:manipulation}#dst,#src{position:absolute;inset:0;width:100%;height:100%;display:block}#dst{opacity:0}#afterWrap{position:absolute;inset:0;overflow:hidden;pointer-events:none}#afterWrap #dst{opacity:1}#divider{position:absolute;left:50%;top:0;bottom:0;width:2px;background:var(--brand);box-shadow:0 0 8px rgba(43,227,138,.6);cursor:col-resize;z-index:50;transform:translateX(-50%);pointer-events:auto;touch-action:none}#info{font-size:11px;color:#7a92c0;margin:6px 0;line-height:1.4;min-height:32px}.autoHint{background:var(--warning);color:#fff;padding:6px 10px;border-radius:6px;font-size:11px;margin:6px 0;display:none;align-items:center;gap:6px}.autoHint.show{display:flex}#processing{position:fixed;inset:0;background:rgba(8,12,20,.95);display:none;align-items:center;justify-content:center;z-index:9999}#processing .content{text-align:center;padding:20px;background:var(--panel);border:1px solid var(--border);border-radius:12px;max-width:85vw}#procMeter{width:260px;height:6px;background:#1b2a45;border-radius:99px;overflow:hidden;margin:12px auto}#procMeter .bar{height:100%;background:linear-gradient(90deg,var(--brand),#20a96f);width:0%;transition:width .2s}#ajDock{position:fixed;right:max(12px,env(safe-area-inset-right));top:50%;transform:translateY(-50%);display:none;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;box-shadow:0 4px 20px rgba(0,0,0,.6);max-width:340px;max-height:70vh;overflow-y:auto;z-index:98}#ajDock.show{display:block}#ajDock h3{margin:0 0 4px 0;font-size:13px;font-weight:600}.ajMeta{font-size:10px;color:#6a7fa0;margin-bottom:8px;line-height:1.4}.ajList{display:flex;flex-direction:column;gap:6px}.ajItem{background:var(--btn);border:1px solid var(--border);border-radius:8px;padding:8px 10px;cursor:pointer;font-size:12px;transition:all .15s;word-break:break-word}.ajItem:active{background:#2a3d5a;transform:scale(.98)}.ajItem strong{display:block;margin-bottom:2px;font-size:13px}.ajItem span{color:#8aa2d2;font-size:11px;display:block}#ajToggle{position:fixed;right:max(12px,env(safe-area-inset-right));bottom:max(12px,calc(12px + env(safe-area-inset-bottom)));width:50px;height:50px;border-radius:50%;background:var(--brand);border:2px solid #0b3c25;color:#072412;font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(43,227,138,.5);z-index:99;transition:all .2s;touch-action:manipulation}#ajToggle:active{transform:scale(.9)}#ajToggle.active{background:var(--warning);border-color:#c70;color:#fff}.heat-group,.xray-group{transition:all .2s}.heat-group.hidden,.xray-group.hidden{display:none}hr{border:none;border-top:1px solid var(--border);margin:10px 0}@media(max-width:600px){.wrap{padding:8px}#ajDock{max-width:calc(100vw - 80px);max-height:50vh;right:8px;top:auto;bottom:max(70px,calc(70px + env(safe-area-inset-bottom)));transform:none}}</style></head><body><div id="loginScreen"><div class="loginBox"><h2>ğŸ‚ Cake Reveal</h2><div class="subtitle">è«‹è¼¸å…¥å¸³è™Ÿå¯†ç¢¼ä»¥ç¹¼çºŒ</div><form id="loginForm" onsubmit="return!1"><div class="inputGroup"><label for="username">å¸³è™Ÿ</label> <input type="text" id="username" placeholder="è«‹è¼¸å…¥å¸³è™Ÿ" autocomplete="off" required></div><div class="inputGroup"><label for="password">å¯†ç¢¼</label> <input type="password" id="password" placeholder="è«‹è¼¸å…¥å¯†ç¢¼" autocomplete="off" required></div><button type="submit" class="loginBtn">ğŸ”“ ç™»å…¥</button><div class="errorMsg" id="errorMsg">âŒ å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡è©¦</div></form></div></div><div class="wrap" id="mainApp" style="display:none"><header><h1>ğŸ‚ Cake Reveal</h1><span class="badge">v12.0 AIå¢å¼·ç‰ˆ</span> <span class="badge">æ™ºèƒ½æ¸¬å…‰+ç´°ç¯€å¢å¼·</span></header><div class="grid"><div class="card"><div class="hflex"><label class="btn primary" style="flex:1"><input type="file" id="fileInput" accept="image/*" style="display:none"> ğŸ“‚ é¸æ“‡åœ–ç‰‡</label> <button class="btn" id="btnHQ">ğŸ”¥ é«˜ç•«è³ª</button></div><div class="autoHint" id="autoHint">âš ï¸ AI å»ºè­°å·²å¥—ç”¨ <button class="btn warning" id="btnUndoAuto" style="padding:4px 8px;font-size:11px;margin-left:auto">â†© é‚„åŸ</button></div><div class="hflex" style="margin-top:8px"><button class="btn" id="btnDL" style="flex:1">ğŸ’¾ ä¸‹è¼‰</button> <button class="btn" id="btnDLMask" style="flex:1">ğŸ­ é®ç½©</button> <button class="btn" id="btnShare" style="flex:1;display:none">ğŸ“¤ åˆ†äº«</button></div><div id="info">â³ ç­‰å¾…åœ–ç‰‡...</div><hr><div class="hflex"><button class="btn" id="btnReset" style="flex:1">âš™ï¸ é‡ç½®</button> <button class="btn" id="btnCopy" style="flex:1">ğŸ“‹ è¤‡è£½</button> <button class="btn" id="btnPaste" style="flex:1">ğŸ“Œ è²¼ä¸Š</button></div><div class="row"><label>é è¦½é‚Šé•· (px) â€¢ å®Œæ•´ç¯„åœ 300-1536px</label> <input type="range" id="pv" min="300" max="1536" step="50" value="800"> <span id="pv_v" style="font-size:11px;color:#8aa2d2">800</span></div><div class="toggle"><label><input type="checkbox" id="ckDeblock"> å»å¡Šç‹€</label> <label><input type="checkbox" id="ckBilateral"> é›™é‚Šæ¿¾æ³¢</label> <label><input type="checkbox" id="ckEnh" checked="checked"> å¢å¼·</label> <label><input type="checkbox" id="ckGuidedDetail"> ğŸ¯ ç´°ç¯€å¢å¼·</label></div><div class="toggle"><label><input type="checkbox" id="ckXray" checked="checked"> ğŸ” é€è¦–</label> <label><input type="checkbox" id="ckHeat"> ğŸ”¥ ç†±å€</label></div><div class="row"><label>å»å¡Šå¹³æ»‘ Ïƒ â€¢ å®Œæ•´ç¯„åœ 0-5</label> <input type="range" id="fbSigma" min="0" max="5" step="0.1" value="1.2"> <span id="fbSigma_v" style="font-size:11px;color:#8aa2d2">1.2</span></div><div class="row"><label>é›™é‚Šæ¿¾æ³¢ç¯„åœ â€¢ å®Œæ•´ 1-100</label> <input type="range" id="bilatR" min="1" max="100" step="1" value="30"> <span id="bilatR_v" style="font-size:11px;color:#8aa2d2">30</span></div><div class="row"><label>é›™é‚Šæ¿¾æ³¢å¼·åº¦ â€¢ å®Œæ•´ 1-100</label> <input type="range" id="bilatS" min="1" max="100" step="1" value="30"> <span id="bilatS_v" style="font-size:11px;color:#8aa2d2">30</span></div><div class="row xray-group"><label>é€è¦–æ¨¡å¼ â€¢ å®Œæ•´5ç¨®</label> <select id="xrayMode"><option value="gain-fast">âš¡ å¿«é€Ÿå¢ç›Š</option><option value="neutral" selected="selected">ğŸ¯ æ¨™æº–é€è¦–</option><option value="adaptive">ğŸ§  è‡ªé©æ‡‰</option><option value="gradient">ğŸŒˆ æ¢¯åº¦ç†±åœ–</option><option value="clahe">ğŸ”¬ CLAHEå°æ¯”</option></select></div><div class="row xray-group"><label>é€è¦–å¼·åº¦ â€¢ å®Œæ•´ 0-12</label> <input type="range" id="xrayK" min="0" max="12" step="0.1" value="4.5"> <span id="xrayK_v" style="font-size:11px;color:#8aa2d2">4.5</span></div><div class="row xray-group"><label>é€è¦–ç´°ç¯€ â€¢ å®Œæ•´ 0-2</label> <input type="range" id="xrayDetail" min="0" max="2" step="0.05" value="1.0"> <span id="xrayDetail_v" style="font-size:11px;color:#8aa2d2">1.0</span></div><div class="row heat-group"><label>ç†±å€è¦†è“‹ â€¢ å®Œæ•´ 0-1</label> <input type="range" id="heatA" min="0" max="1" step="0.05" value="0.6"> <span id="heatA_v" style="font-size:11px;color:#8aa2d2">0.6</span></div><div class="row"><label>éŠ³åŒ– â€¢ å®Œæ•´ 0-3</label> <input type="range" id="usmK" min="0" max="3" step="0.05" value="1.0"> <span id="usmK_v" style="font-size:11px;color:#8aa2d2">1.0</span></div><div class="row"><label>é‚Šç·£å¼·åº¦ â€¢ ç²¾åº¦ 0.05</label> <input type="range" id="edge" min="0" max="1" step="0.05" value="0.4"> <span id="edge_v" style="font-size:11px;color:#8aa2d2">0.4</span></div><div class="row"><label>æµ®é›• â€¢ å®Œæ•´ 0-1</label> <input type="range" id="emboss" min="0" max="1" step="0.05" value="0.2"> <span id="emboss_v" style="font-size:11px;color:#8aa2d2">0.2</span></div><div class="row"><label>é™°å½± â€¢ å®Œæ•´ 0-1</label> <input type="range" id="shadow" min="0" max="1" step="0.05" value="0.4"> <span id="shadow_v" style="font-size:11px;color:#8aa2d2">0.4</span></div><div class="row"><label>å»éœ§/æŸ”åŒ– â€¢ å®Œæ•´ 0-3</label> <input type="range" id="blur" min="0" max="3" step="0.1" value="0"> <span id="blur_v" style="font-size:11px;color:#8aa2d2">0</span></div></div><div class="card"><div class="compareWrap" id="compareWrap"><canvas id="src"></canvas><div id="afterWrap"><canvas id="dst"></canvas></div><div id="divider"></div></div><div style="margin-top:6px;font-size:10px;color:#6a7fa0">ğŸ’¡ æ‹–å‹•ä¸­ç·šæŸ¥çœ‹å°æ¯” | å¿«æ·éµ: O=é–‹å•Ÿ H=é«˜ç•«è³ª S=å„²å­˜</div></div></div></div><div id="processing"><div class="content"><div style="font-size:14px;margin-bottom:10px;font-weight:600">â³ è™•ç†ä¸­...</div><div id="procMeta" style="font-size:11px;color:#8aa2d2;margin-bottom:8px"></div><div id="procMeter"><div class="bar"></div></div><button class="btn" id="btnCancel" style="margin-top:12px">â¹ï¸ å–æ¶ˆ</button></div></div><div id="ajDock"><h3>ğŸ§  AI å®Œæ•´æ™ºèƒ½åˆ†æ</h3><div class="ajMeta" id="ajMeta"></div><div class="ajList" id="ajList"></div></div><button id="ajToggle" title="AIæ™ºèƒ½å»ºè­°">ğŸ§ </button><script>!function(){"use strict";const e="1234",t="cakeRevealAuth";function n(){const n=sessionStorage.getItem(t);if(n)try{const t=JSON.parse(n);if(t.username===e&&t.timestamp&&Date.now()-t.timestamp<864e5)return!0}catch(e){}return!1}function a(){const e=/iPad|iPhone|iPod/.test(navigator.userAgent),t=e?16777216:268435456,n=e?4096:32767,a=Math.min(navigator.hardwareConcurrency||4,e?2:4);console.log(`ğŸ‚ v12.0 AIå¢å¼·ç‰ˆ | iOS=${e} | Workers=${a}`),console.log("âœ… æ™ºèƒ½æ¸¬å…‰åˆ†æ + Guided Filterç´°ç¯€å¢å¼· + 8ç¨®AIæ¨è–¦ + æ€§èƒ½å„ªåŒ–");const s=e=>document.getElementById(e),o=s("src"),r=s("dst"),i=o.getContext("2d",{willReadFrequently:!0}),c=r.getContext("2d"),l=s("compareWrap"),d=s("divider"),m=s("afterWrap"),y=s("processing"),h=s("procMeter").querySelector(".bar"),u=s("ajDock"),g=s("ajList"),x=s("ajMeta"),p=s("ajToggle"),f=s("autoHint"),w=s("btnUndoAuto"),b={latest:0,loaded:!1,bitmap:null,w:0,h:0,processing:!1,isDragging:!1,ajOpen:!1,scheduleTimer:null,clipboard:null,workers:[],autoApplied:!1,prevParams:null,analysisCache:null,bufferPool:new Map,processTimeout:null};function v(e,t,n){return Math.max(t,Math.min(n,e))}const k=e=>{s("info").textContent=e};function M(){return{pv:+s("pv").value,ckDeblock:s("ckDeblock").checked,ckBilateral:s("ckBilateral").checked,fbSigma:+s("fbSigma").value,bilatR:+s("bilatR").value,bilatS:+s("bilatS").value,ckEnh:s("ckEnh").checked,ckGuidedDetail:s("ckGuidedDetail").checked,usmK:+s("usmK").value,edge:+s("edge").value,emboss:+s("emboss").value,shadow:+s("shadow").value,blur:+s("blur").value,ckXray:s("ckXray").checked,xrayMode:s("xrayMode").value,xrayK:+s("xrayK").value,xrayDetail:+s("xrayDetail").value,ckHeat:s("ckHeat").checked,heatA:+s("heatA").value}}function A(e,t=!1,n=!1){n&&(b.prevParams=M(),b.autoApplied=!0,f.classList.add("show"));const a={pv:"pv",fbSigma:"fbSigma",bilatR:"bilatR",bilatS:"bilatS",usmK:"usmK",edge:"edge",emboss:"emboss",shadow:"shadow",blur:"blur",xrayK:"xrayK",xrayDetail:"xrayDetail",heatA:"heatA"};for(const t in a)if(null!=e[t]){s(a[t]).value=e[t];const n=s(a[t]+"_v");n&&(n.textContent=e[t])}null!=e.ckDeblock&&(s("ckDeblock").checked=!!e.ckDeblock),null!=e.ckBilateral&&(s("ckBilateral").checked=!!e.ckBilateral),null!=e.ckEnh&&(s("ckEnh").checked=!!e.ckEnh),null!=e.ckXray&&(s("ckXray").checked=!!e.ckXray),null!=e.ckHeat&&(s("ckHeat").checked=!!e.ckHeat),e.xrayMode&&(s("xrayMode").value=e.xrayMode),E(),t||Y()}function E(){document.querySelectorAll(".xray-group").forEach(e=>{e.classList.toggle("hidden",!s("ckXray").checked)}),document.querySelectorAll(".heat-group").forEach(e=>{e.classList.toggle("hidden",!s("ckHeat").checked)})}w.addEventListener("click",()=>{b.prevParams&&(A(b.prevParams),b.autoApplied=!1,f.classList.remove("show"),k("â†© å·²é‚„åŸ"))}),s("fileInput").addEventListener("change",e=>async function(e){if(e){$(),k("ğŸ“¸ è¼‰å…¥ä¸­...");try{let a;try{a=await createImageBitmap(e,{imageOrientation:"from-image"})}catch(t){const n=URL.createObjectURL(e),s=new Image;await new Promise((e,t)=>{s.onload=e,s.onerror=t,s.src=n}),a=await createImageBitmap(s),URL.revokeObjectURL(n)}let o=a.width,r=a.height;if(o*r>t){const e=Math.sqrt(t/(o*r));o=Math.floor(o*e),r=Math.floor(r*e)}o=Math.min(o,n),r=Math.min(r,n),b.bitmap=a,b.w=o,b.h=r,b.loaded=!0,R(),k(`âœ… ${o}Ã—${r} px`),s("fileInput").value="",S()}catch(e){console.error(e),k(`âŒ ${e.message}`),R()}}}(e.target.files[0]));const L=new Blob(["\n  'use strict';\n  \n  self.clamp = (v,a,b) => Math.max(a, Math.min(b, v));\n  \n  // å„ªåŒ–çš„ Stack Blur (å®Œæ•´é‚Šç•Œè™•ç†)\n  function stackBlur(src, w, h, r) {\n    if(r < 1) return new Float32Array(src);\n    \n    const dst = new Float32Array(w*h);\n    const div = (r+1) * (r+1);\n    \n    // æ°´å¹³\n    for(let y=0; y<h; y++) {\n      let sum = src[y*w] * (r+1);\n      for(let i=1; i<=r; i++) {\n        sum += src[y*w + self.clamp(i, 0, w-1)];\n      }\n      \n      dst[y*w] = sum / div;\n      \n      for(let x=1; x<w; x++) {\n        const left = self.clamp(x-r-1, 0, w-1);\n        const right = self.clamp(x+r, 0, w-1);\n        sum -= src[y*w + left];\n        sum += src[y*w + right];\n        dst[y*w + x] = sum / div;\n      }\n    }\n    \n    // å‚ç›´\n    const tmp = dst.slice();\n    for(let x=0; x<w; x++) {\n      let sum = tmp[x] * (r+1);\n      for(let i=1; i<=r; i++) {\n        sum += tmp[self.clamp(i, 0, h-1)*w + x];\n      }\n      \n      dst[x] = sum / div;\n      \n      for(let y=1; y<h; y++) {\n        const top = self.clamp(y-r-1, 0, h-1);\n        const bottom = self.clamp(y+r, 0, h-1);\n        sum -= tmp[top*w + x];\n        sum += tmp[bottom*w + x];\n        dst[y*w + x] = sum / div;\n      }\n    }\n    \n    return dst;\n  }\n  \n  // å„ªåŒ–çš„ Subsampling Bilateral\n  function fastBilateral(src, w, h, spatialSigma, colorSigma) {\n    const r = Math.ceil(spatialSigma);\n    const dst = new Float32Array(w*h);\n    const r2 = 2*spatialSigma*spatialSigma;\n    const c2 = 2*colorSigma*colorSigma;\n    \n    for(let y=0; y<h; y++) {\n      for(let x=0; x<w; x++) {\n        let sum=0, wsum=0;\n        const centerVal = src[y*w+x];\n        \n        for(let dy=-r; dy<=r; dy++) {\n          for(let dx=-r; dx<=r; dx++) {\n            const nx=self.clamp(x+dx,0,w-1), ny=self.clamp(y+dy,0,h-1);\n            const val = src[ny*w+nx];\n            const cd = (val - centerVal) * (val - centerVal);\n            const sd = dx*dx + dy*dy;\n            \n            const gw = Math.exp(-sd/r2 - cd/c2);\n            sum += val * gw;\n            wsum += gw;\n          }\n        }\n        dst[y*w+x] = wsum > 0 ? sum/wsum : centerVal;\n      }\n    }\n    return dst;\n  }\n  \n  // CLAHE with é‚Šç•Œå¹³æ»‘\n  function clahe(gray, w, h, clipLimit=2.0, tileSize=8) {\n    const tilesX = Math.ceil(w / tileSize);\n    const tilesY = Math.ceil(h / tileSize);\n    const cdfs = [];\n    \n    for(let ty=0; ty<tilesY; ty++) {\n      for(let tx=0; tx<tilesX; tx++) {\n        const x0 = tx * tileSize;\n        const y0 = ty * tileSize;\n        const x1 = Math.min(x0 + tileSize, w);\n        const y1 = Math.min(y0 + tileSize, h);\n        const tilePixels = (x1-x0) * (y1-y0);\n        \n        const hist = new Array(256).fill(0);\n        for(let y=y0; y<y1; y++) {\n          for(let x=x0; x<x1; x++) {\n            hist[Math.floor(gray[y*w+x])]++;\n          }\n        }\n        \n        const limit = Math.max(1, Math.floor(clipLimit * tilePixels / 256));\n        let excess = 0;\n        for(let i=0; i<256; i++) {\n          if(hist[i] > limit) {\n            excess += hist[i] - limit;\n            hist[i] = limit;\n          }\n        }\n        for(let i=0; i<256; i++) hist[i] += Math.floor(excess / 256);\n        \n        const cdf = new Array(256);\n        cdf[0] = hist[0];\n        for(let i=1; i<256; i++) cdf[i] = cdf[i-1] + hist[i];\n        \n        cdfs.push(cdf);\n      }\n    }\n    \n    const out = new Float32Array(w*h);\n    for(let y=0; y<h; y++) {\n      for(let x=0; x<w; x++) {\n        const tx = Math.min(Math.floor(x / tileSize), tilesX-1);\n        const ty = Math.min(Math.floor(y / tileSize), tilesY-1);\n        const tileIdx = ty * tilesX + tx;\n        const val = Math.floor(gray[y*w+x]);\n        const cdf = cdfs[tileIdx];\n        out[y*w+x] = (cdf[val] / cdf[255]) * 255;\n      }\n    }\n    return out;\n  }\n  \n  // Guided Filter - é‚Šç·£ä¿æŒå¹³æ»‘\n  function guidedFilter(input, guide, w, h, radius, eps) {\n    const r = radius;\n    const N = boxFilter(createOnes(w, h), w, h, r);\n    \n    const meanI = boxFilterDivide(boxFilter(input, w, h, r), N, w, h);\n    const meanP = boxFilterDivide(boxFilter(guide, w, h, r), N, w, h);\n    const corrI = boxFilterDivide(boxFilter(multiply(input, input, w, h), w, h, r), N, w, h);\n    const corrIp = boxFilterDivide(boxFilter(multiply(input, guide, w, h), w, h, r), N, w, h);\n    \n    const varI = subtract(corrI, multiply(meanI, meanI, w, h), w, h);\n    const covIp = subtract(corrIp, multiply(meanI, meanP, w, h), w, h);\n    \n    const a = new Float32Array(w * h);\n    const b = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      a[i] = covIp[i] / (varI[i] + eps);\n      b[i] = meanP[i] - a[i] * meanI[i];\n    }\n    \n    const meanA = boxFilterDivide(boxFilter(a, w, h, r), N, w, h);\n    const meanB = boxFilterDivide(boxFilter(b, w, h, r), N, w, h);\n    \n    const q = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      q[i] = meanA[i] * input[i] + meanB[i];\n    }\n    return q;\n  }\n  \n  // Box Filter è¼”åŠ©å‡½æ•¸\n  function boxFilter(src, w, h, r) {\n    const dst = new Float32Array(w * h);\n    const temp = new Float32Array(w * h);\n    \n    // æ°´å¹³\n    for(let y=0; y<h; y++) {\n      let sum = 0;\n      for(let x=-r; x<=r; x++) {\n        const px = self.clamp(x, 0, w-1);\n        sum += src[y*w + px];\n      }\n      temp[y*w] = sum;\n      \n      for(let x=1; x<w; x++) {\n        const left = self.clamp(x-r-1, 0, w-1);\n        const right = self.clamp(x+r, 0, w-1);\n        sum = sum - src[y*w + left] + src[y*w + right];\n        temp[y*w + x] = sum;\n      }\n    }\n    \n    // å‚ç›´\n    for(let x=0; x<w; x++) {\n      let sum = 0;\n      for(let y=-r; y<=r; y++) {\n        const py = self.clamp(y, 0, h-1);\n        sum += temp[py*w + x];\n      }\n      dst[x] = sum;\n      \n      for(let y=1; y<h; y++) {\n        const top = self.clamp(y-r-1, 0, h-1);\n        const bottom = self.clamp(y+r, 0, h-1);\n        sum = sum - temp[top*w + x] + temp[bottom*w + x];\n        dst[y*w + x] = sum;\n      }\n    }\n    return dst;\n  }\n  \n  function createOnes(w, h) {\n    return new Float32Array(w * h).fill(1);\n  }\n  \n  function boxFilterDivide(src, divisor, w, h) {\n    const dst = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      dst[i] = src[i] / divisor[i];\n    }\n    return dst;\n  }\n  \n  function multiply(a, b, w, h) {\n    const dst = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      dst[i] = a[i] * b[i];\n    }\n    return dst;\n  }\n  \n  function subtract(a, b, w, h) {\n    const dst = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      dst[i] = a[i] - b[i];\n    }\n    return dst;\n  }\n  \n  // å¤šå°ºåº¦ç´°ç¯€å¢å¼·ï¼ˆAdobe Lightroom é¢¨æ ¼ï¼‰\n  function enhanceDetailMultiScale(src, w, h, gains) {\n    const scales = [4, 8, 16];\n    const details = [];\n    \n    // æå–æ¯å€‹å°ºåº¦çš„ç´°ç¯€\n    for(let i=0; i<scales.length; i++) {\n      const r = scales[i];\n      const base = guidedFilter(src, src, w, h, r, 0.04);\n      const detail = new Float32Array(w * h);\n      for(let j=0; j<w*h; j++) {\n        detail[j] = src[j] - base[j];\n      }\n      details.push(detail);\n    }\n    \n    // æ ¹æ“šå¢ç›Šçµ„åˆç´°ç¯€\n    const combined = new Float32Array(w * h);\n    for(let i=0; i<w*h; i++) {\n      combined[i] = src[i] + \n        details[0][i] * gains.fine +\n        details[1][i] * gains.mid +\n        details[2][i] * gains.coarse;\n    }\n    \n    return combined;\n  }\n  \n  // GLCM å®Œæ•´åˆ†æ\n  function calcGLCM(gray, w, h, d=1) {\n    const glcm = Array(256).fill(0).map(() => Array(256).fill(0));\n    for(let y=0; y<h-d; y++) {\n      for(let x=0; x<w-d; x++) {\n        const i = Math.floor(gray[y*w+x]);\n        const j = Math.floor(gray[(y+d)*w+(x+d)]);\n        glcm[i][j]++;\n      }\n    }\n    let sum = 0;\n    for(let i=0; i<256; i++) for(let j=0; j<256; j++) sum += glcm[i][j];\n    if(sum > 0) for(let i=0; i<256; i++) for(let j=0; j<256; j++) glcm[i][j] /= sum;\n    \n    let contrast=0, energy=0, homogeneity=0;\n    for(let i=0; i<256; i++) {\n      for(let j=0; j<256; j++) {\n        const p = glcm[i][j];\n        contrast += (i-j)*(i-j) * p;\n        energy += p * p;\n        homogeneity += p / (1 + Math.abs(i-j));\n      }\n    }\n    return {contrast, energy, homogeneity};\n  }\n  \n  // ä¸»è™•ç†é‚è¼¯\n  self.onmessage = (e) => {\n    const {type, jobId, w, h, buf, params, chunkId, startY, endY} = e.data;\n    \n    if(type === 'analyze') {\n      const d = new Uint8ClampedArray(buf);\n      const gray = new Float32Array(w*h);\n      for(let i=0; i<w*h; i++) {\n        gray[i] = d[i*4]*0.299 + d[i*4+1]*0.587 + d[i*4+2]*0.114;\n      }\n      \n      const glcm = calcGLCM(gray, w, h, 1);\n      \n      let indent=0, bump=0, vshape=0, entropy=0;\n      for(let y=1; y<h-1; y++) {\n        for(let x=1; x<w-1; x++) {\n          const c = gray[y*w+x];\n          const t = gray[(y-1)*w+x], b = gray[(y+1)*w+x];\n          const l = gray[y*w+(x-1)], r = gray[y*w+(x+1)];\n          \n          const lap = Math.abs(4*c - t - b - l - r);\n          if(lap > 20) bump += lap;\n          if(c < Math.min(t,b,l,r) - 10) indent += 1;\n          \n          const gx = r - l, gy = b - t;\n          if(Math.abs(gx) > 10 && Math.abs(gy) > 10) vshape += 1;\n        }\n      }\n      \n      const hist = new Array(256).fill(0);\n      let sum = 0;\n      for(let i=0; i<gray.length; i++) {\n        const val = Math.floor(gray[i]);\n        hist[val]++;\n        sum += gray[i];\n      }\n      for(let i=0; i<256; i++) {\n        const p = hist[i] / gray.length;\n        if(p > 0) entropy -= p * Math.log2(p);\n      }\n      \n      indent = indent / (w * h);\n      bump = bump / (w * h * 100);\n      vshape = vshape / (w * h);\n      \n      let meanEdge = 0;\n      for(let y=1; y<h-1; y++) {\n        for(let x=1; x<w-1; x++) {\n          const gx = gray[y*w+(x+1)] - gray[y*w+(x-1)];\n          const gy = gray[(y+1)*w+x] - gray[(y-1)*w+x];\n          meanEdge += Math.sqrt(gx*gx + gy*gy);\n        }\n      }\n      meanEdge /= (w-2)*(h-2);\n      \n      // æ›å…‰åˆ†æ\n      const mean = sum / gray.length;\n      const sorted = Array.from(gray).sort((a,b) => a-b);\n      const median = sorted[Math.floor(sorted.length/2)];\n      \n      let variance = 0;\n      for(let i=0; i<gray.length; i++) {\n        variance += Math.pow(gray[i] - mean, 2);\n      }\n      const stdDev = Math.sqrt(variance / gray.length);\n      \n      const clipLow = hist.slice(0, 10).reduce((a,b)=>a+b, 0) / gray.length;\n      const clipHigh = hist.slice(245).reduce((a,b)=>a+b, 0) / gray.length;\n      \n      const exposure = {\n        mean: mean,\n        median: median,\n        stdDev: stdDev,\n        clipLow: clipLow,\n        clipHigh: clipHigh,\n        isUnderexposed: mean < 80 && clipLow > 0.02,\n        isOverexposed: mean > 180 && clipHigh > 0.02,\n        isDynamic: Math.max(clipLow, clipHigh) < 0.01 && mean > 100 && mean < 150,\n        isLowContrast: stdDev < 30,\n        isHighContrast: stdDev > 70\n      };\n      \n      self.postMessage({type:'analyze-done', jobId, metrics: {indent, bump, vshape, entropy, meanEdge, glcm, exposure}});\n      return;\n    }\n    \n    if(type === 'mask') {\n      const d = new Uint8ClampedArray(buf);\n      const out = new Uint8ClampedArray(w*h*4);\n      \n      for(let y=1; y<h-1; y++) {\n        for(let x=1; x<w-1; x++) {\n          let sum = 0;\n          for(let c=0; c<3; c++) {\n            const idx = (y*w+x)*4+c;\n            const dx = d[idx+4] - d[idx-4];\n            const dy = d[idx+w*4] - d[idx-w*4];\n            sum += Math.sqrt(dx*dx + dy*dy);\n          }\n          const intensity = self.clamp(sum / 3, 0, 255);\n          const idx = (y*w+x)*4;\n          out[idx] = out[idx+1] = out[idx+2] = intensity;\n          out[idx+3] = 255;\n        }\n      }\n      self.postMessage({type:'mask-done', jobId, buf:out.buffer}, [out.buffer]);\n      return;\n    }\n    \n    if(type !== 'job') return;\n    \n    const postProgress = (pct) => self.postMessage({type:'progress', jobId, chunkId, pct});\n    postProgress(5);\n    \n    const d = new Uint8ClampedArray(buf);\n    const out = new Uint8ClampedArray((endY-startY)*w*4);\n    \n    const getAt = (x,y,c) => {\n      if(x<0||x>=w||y<startY||y>=endY) return 0;\n      return d[((y-startY)*w+x)*4+c];\n    };\n    const setAt = (x,y,c,v) => {\n      if(x<0||x>=w||y<startY||y>=endY) return;\n      out[((y-startY)*w+x)*4+c] = self.clamp(v, 0, 255);\n    };\n    \n    for(let i=0; i<d.length; i++) out[i] = d[i];\n    \n    postProgress(10);\n    \n    if(params.ckDeblock && params.fbSigma > 0) {\n      const r = Math.ceil(params.fbSigma);\n      for(let c=0; c<3; c++) {\n        const channel = new Float32Array((endY-startY)*w);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          channel[i] = getAt(x,y,c);\n        }\n        const blurred = stackBlur(channel, w, endY-startY, r);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          setAt(x,y,c, blurred[i]);\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    postProgress(20);\n    \n    if(params.ckBilateral && params.bilatR > 0) {\n      const spatialSigma = params.bilatR / 3;\n      const colorSigma = params.bilatS;\n      for(let c=0; c<3; c++) {\n        const channel = new Float32Array((endY-startY)*w);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          channel[i] = getAt(x,y,c);\n        }\n        const filtered = fastBilateral(channel, w, endY-startY, spatialSigma, colorSigma);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          setAt(x,y,c, filtered[i]);\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    postProgress(35);\n    \n    let edgeMap = null;\n    if(params.ckXray) {\n      edgeMap = new Float32Array((endY-startY)*w);\n      \n      for(let y=startY+1; y<endY-1; y++) {\n        for(let x=1; x<w-1; x++) {\n          let gx=0, gy=0;\n          for(let c=0; c<3; c++) {\n            gx += getAt(x+1,y,c) - getAt(x-1,y,c);\n            gy += getAt(x,y+1,c) - getAt(x,y-1,c);\n          }\n          edgeMap[(y-startY)*w+x] = Math.sqrt(gx*gx + gy*gy);\n        }\n      }\n      \n      postProgress(55);\n      \n      let maxE = 0;\n      for(let i=0; i<edgeMap.length; i++) maxE = Math.max(maxE, edgeMap[i]);\n      \n      const mode = params.xrayMode;\n      const k = params.xrayK;\n      const detail = params.xrayDetail;\n      \n      if(mode === 'clahe') {\n        const gray = new Float32Array((endY-startY)*w);\n        for(let i=0; i<gray.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          gray[i] = (getAt(x,y,0)+getAt(x,y,1)+getAt(x,y,2))/3;\n        }\n        const enhanced = clahe(gray, w, endY-startY, 2.0, 8);\n        for(let y=startY; y<endY; y++) {\n          for(let x=0; x<w; x++) {\n            const idx = (y-startY)*w+x;\n            const boost = enhanced[idx] - gray[idx];\n            for(let c=0; c<3; c++) {\n              setAt(x,y,c, getAt(x,y,c) + boost + edgeMap[idx]/maxE*k*40);\n            }\n          }\n        }\n      } else {\n        for(let y=startY; y<endY; y++) {\n          for(let x=0; x<w; x++) {\n            const idx = (y-startY)*w+x;\n            let edge = edgeMap[idx];\n            edge = Math.pow(edge / maxE, 0.7 - detail*0.2) * maxE;\n            \n            if(mode === 'gain-fast') {\n              const gain = 1 + edge / 255 * k * 2.0;\n              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * gain);\n            } else if(mode === 'neutral') {\n              const boost = edge / maxE * k * 120;\n              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) + boost);\n            } else if(mode === 'adaptive') {\n              const localVar = Math.abs(edge - (maxE * 0.3));\n              const adaptiveGain = 1 + (edge / 255) * k * (1 + localVar / maxE * detail);\n              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * adaptiveGain);\n            } else if(mode === 'gradient') {\n              const intensity = self.clamp(edge / maxE * k * 120, 0, 255);\n              for(let c=0; c<3; c++) setAt(x,y,c, getAt(x,y,c) * 0.6 + intensity * 0.4);\n            }\n          }\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    postProgress(70);\n    \n    // Guided Filter ç´°ç¯€å¢å¼·ï¼ˆæ–°å¢ï¼‰\n    if(params.ckGuidedDetail) {\n      for(let c=0; c<3; c++) {\n        const channel = new Float32Array((endY-startY)*w);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          channel[i] = getAt(x,y,c);\n        }\n        \n        // ä½¿ç”¨å¤šå°ºåº¦ç´°ç¯€å¢å¼·\n        const enhanced = enhanceDetailMultiScale(channel, w, endY-startY, {\n          fine: 1.5,   // ç´°å°ç´‹ç†å¼·åŒ–\n          mid: 1.2,    // ä¸­ç­‰ç´‹ç†\n          coarse: 0.8  // ç²—ç³™ç´‹ç†ç•¥é™\n        });\n        \n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          setAt(x,y,c, enhanced[i]);\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    if(params.ckEnh) {\n      if(params.usmK > 0) {\n        for(let c=0; c<3; c++) {\n          const channel = new Float32Array((endY-startY)*w);\n          for(let i=0; i<channel.length; i++) {\n            const y = Math.floor(i/w) + startY;\n            const x = i%w;\n            channel[i] = getAt(x,y,c);\n          }\n          const blurred = stackBlur(channel, w, endY-startY, 2);\n          for(let i=0; i<channel.length; i++) {\n            const y = Math.floor(i/w) + startY;\n            const x = i%w;\n            const orig = getAt(x,y,c);\n            setAt(x,y,c, orig + (orig - blurred[i]) * params.usmK);\n          }\n        }\n        for(let i=0; i<out.length; i++) d[i] = out[i];\n      }\n      \n      if(params.edge > 0 || params.emboss > 0 || params.shadow > 0) {\n        for(let y=startY+1; y<endY-1; y++) {\n          for(let x=1; x<w-1; x++) {\n            for(let c=0; c<3; c++) {\n              const v = getAt(x,y,c);\n              const dx = getAt(x+1,y,c) - getAt(x-1,y,c);\n              const dy = getAt(x,y+1,c) - getAt(x,y-1,c);\n              \n              const embossVal = (-2*getAt(x-1,y-1,c) - getAt(x,y-1,c) - getAt(x-1,y,c) +\n                                 getAt(x,y,c) + getAt(x+1,y,c) + getAt(x,y+1,c) +\n                                 getAt(x-1,y+1,c) + 2*getAt(x+1,y+1,c)) / 9;\n              \n              const edgeMag = Math.sqrt(dx*dx + dy*dy);\n              const edge = edgeMag * params.edge;\n              const emboss = embossVal * params.emboss * 100;\n              const shadow = -Math.abs(dx + dy) * params.shadow;\n              setAt(x,y,c, v + edge + emboss + shadow);\n            }\n          }\n        }\n        for(let i=0; i<out.length; i++) d[i] = out[i];\n      }\n    }\n    \n    postProgress(85);\n    \n    if(params.ckHeat && edgeMap) {\n      const alpha = params.heatA;\n      let maxE = 0;\n      for(let i=0; i<edgeMap.length; i++) maxE = Math.max(maxE, edgeMap[i]);\n      for(let y=startY; y<endY; y++) {\n        for(let x=0; x<w; x++) {\n          const e = maxE > 0 ? edgeMap[(y-startY)*w+x] / maxE : 0;\n          const heat = e > 0.5 ? [255, (1-e)*510, 0] : [e*510, 255, 0];\n          for(let c=0; c<3; c++) {\n            const v = getAt(x,y,c);\n            setAt(x,y,c, v*(1-alpha) + heat[c]*alpha);\n          }\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    if(params.blur > 0) {\n      const r = Math.ceil(params.blur);\n      for(let c=0; c<3; c++) {\n        const channel = new Float32Array((endY-startY)*w);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          channel[i] = getAt(x,y,c);\n        }\n        const blurred = stackBlur(channel, w, endY-startY, r);\n        for(let i=0; i<channel.length; i++) {\n          const y = Math.floor(i/w) + startY;\n          const x = i%w;\n          setAt(x,y,c, blurred[i]);\n        }\n      }\n      for(let i=0; i<out.length; i++) d[i] = out[i];\n    }\n    \n    postProgress(100);\n    self.postMessage({type:'done', jobId, chunkId, buf:out.buffer, startY, endY}, [out.buffer]);\n  };\n  "],{type:"application/javascript"}),D=URL.createObjectURL(L);function F(e,t){e.onerror=e=>{console.error(`Worker ${t} error:`,e),k("âŒ Worker éŒ¯èª¤ï¼Œé‡å•Ÿä¸­..."),clearTimeout(b.processTimeout),b.workers[t].terminate(),b.workers[t]=new Worker(D),F(b.workers[t],t)},e.onmessage=e=>{const{type:t,jobId:n,pct:s,buf:o,metrics:i,chunkId:l,startY:d,endY:m}=e.data;if("analyze-done"===t)return b.analysisCache=i,j(),void Y();if("mask-done"===t){const e=new Uint8ClampedArray(o),t=document.createElement("canvas");t.width=r.width,t.height=r.height;return t.getContext("2d").putImageData(new ImageData(e,t.width,t.height),0,0),t.toBlob(e=>{const t=URL.createObjectURL(e),n=document.createElement("a");n.href=t,n.download="mask.png",document.body.appendChild(n),n.click(),document.body.removeChild(n),setTimeout(()=>URL.revokeObjectURL(t),100)},"image/png",.95),void k("âœ… å·²ä¸‹è¼‰é®ç½©")}if(n===b.latest)if("progress"===t){const e=(s+100*l)/a;h.style.width=e+"%"}else if("done"===t){const e=new Uint8ClampedArray(o);if(c.putImageData(new ImageData(e,r.width,m-d),0,d),b.workers[l].done=!0,b.workers.every(e=>e.done)){clearTimeout(b.processTimeout);const e=Date.now()-b.startTime;console.log(`âœ… å®Œæˆ: ${e}ms`),y.style.display="none",b.processing=!1,h.style.width="0%",R(),b.workers.forEach(e=>e.done=!1),k(`âœ… ${e}ms`)}}}}function Y(){b.scheduleTimer&&clearTimeout(b.scheduleTimer),b.scheduleTimer=setTimeout(()=>I(!0),150)}async function I(e=!0){if(!b.loaded)return;$();const t=M();let l=b.w,d=b.h;if(e){const e=t.pv,n=Math.min(1,e/Math.max(l,d));l=Math.round(l*n),d=Math.round(d*n)}l=Math.min(l,n),d=Math.min(d,n),o.width===l&&o.height===d||(o.width=l,o.height=d,r.width=l,r.height=d,i.clearRect(0,0,l,d),c.clearRect(0,0,l,d));try{i.drawImage(b.bitmap,0,0,l,d);const n=i.getImageData(0,0,l,d);b.latest=Date.now(),b.startTime=b.latest,e||(y.style.display="flex",b.processing=!0,s("procMeta").textContent=`${l}Ã—${d} px | ${a} Workers`,clearTimeout(b.processTimeout),b.processTimeout=setTimeout(()=>{console.error("âŒ è™•ç†è¶…æ™‚"),k("âŒ è™•ç†è¶…æ™‚ï¼Œå·²å–æ¶ˆ"),b.latest=Date.now()+1e5,y.style.display="none",b.processing=!1,R()},6e4));const o=Math.ceil(d/a);for(let e=0;e<a;e++){const a=e*o,s=Math.min((e+1)*o,d),r=new Uint8ClampedArray(n.data.buffer,a*l*4,(s-a)*l*4);b.workers[e].postMessage({type:"job",jobId:b.latest,chunkId:e,w:l,h:d,startY:a,endY:s,buf:r.buffer,params:t},[r.buffer])}}catch(e){console.error(e),k("âŒ è™•ç†å¤±æ•—"),R()}}function S(){if(!b.loaded)return;const e=document.createElement("canvas"),t=Math.min(b.w,512),n=Math.min(b.h,512);e.width=t,e.height=n;const a=e.getContext("2d");a.drawImage(b.bitmap,0,0,t,n);const s=a.getImageData(0,0,t,n);e.width=e.height=1,b.workers[0].postMessage({type:"analyze",jobId:Date.now(),w:t,h:n,buf:s.data.buffer},[s.data.buffer])}function j(){if(!b.loaded||!b.analysisCache)return;const e=b.w,t=b.h,n=(e*t/1e6).toFixed(1),{indent:a,bump:s,vshape:o,entropy:r,meanEdge:i,glcm:c,exposure:l}=b.analysisCache;x.innerHTML=`\n      ğŸ“Š ${e}Ã—${t}px (${n}MP) | ç†µ: ${r.toFixed(1)}<br>\n      æ›å…‰: ${l.mean.toFixed(0)} | æ¨™æº–å·®: ${l.stdDev.toFixed(1)} | ä¸­ä½æ•¸: ${l.median.toFixed(0)}<br>\n      å£“ç—•: ${(1e3*a).toFixed(1)} | å‡¸èµ·: ${s.toFixed(2)} | é‚Šç·£: ${i.toFixed(1)}<br>\n      GLCM â†’ å°æ¯”: ${c.contrast.toFixed(1)} | èƒ½é‡: ${c.energy.toFixed(3)}\n    `;const d=[];l.isUnderexposed&&d.push({label:"ğŸŒ™ æ›å…‰ä¸è¶³ä¿®å¾©",desc:`æäº®æš—éƒ¨ï¼ˆå¹³å‡ ${l.mean.toFixed(0)}ï¼Œæš—éƒ¨ ${(100*l.clipLow).toFixed(1)}%ï¼‰`,params:{xrayMode:"clahe",xrayK:10,xrayDetail:1.8,edge:.7,usmK:2.2,shadow:.65,ckDeblock:!0,fbSigma:2},badges:["AIæ¨è–¦","æ›å…‰"]}),l.isOverexposed&&d.push({label:"â˜€ï¸ éæ›ä¿®å¾©",desc:`å£“ç¸®é«˜å…‰ï¼ˆå¹³å‡ ${l.mean.toFixed(0)}ï¼Œäº®éƒ¨ ${(100*l.clipHigh).toFixed(1)}%ï¼‰`,params:{xrayMode:"neutral",xrayK:3.5,xrayDetail:.8,edge:.3,shadow:.2,ckBilateral:!0,fbSigma:1.8},badges:["é«˜å…‰"]}),a>.018&&s>1.8&&c.contrast>80&&d.push({label:"ğŸ‚ æ¥µé«˜ç´‹ç†",desc:`è±å¯Œæ°£å­”ï¼ˆå£“ç—• ${(1e3*a).toFixed(1)}ï¼Œå‡¸èµ· ${s.toFixed(2)}ï¼‰`,params:{xrayMode:"adaptive",xrayK:8.5,xrayDetail:1.6,edge:.85,emboss:.4,usmK:2.5,ckDeblock:!0,fbSigma:2.4,ckBilateral:!0},badges:["AIæ¨è–¦","ğŸ”¥"]}),c.energy<.008&&d.push({label:"ğŸ§¹ å¼·åŠ›é™å™ª",desc:`é«˜å™ªé»æª¢æ¸¬ï¼ˆèƒ½é‡ ${c.energy.toFixed(4)}ï¼‰`,params:{ckBilateral:!0,fbSigma:3.5,ckDeblock:!0,xrayMode:"neutral",xrayK:3,xrayDetail:.6,edge:.3,usmK:.8},badges:["é™å™ª"]}),l.isDynamic&&c.contrast>60&&!l.isUnderexposed&&!l.isOverexposed&&d.push({label:"âœ¨ å®Œç¾æ›å…‰å¢å¼·",desc:`å‹•æ…‹ç¯„åœå„ªç§€ï¼Œå¼·åŒ–ç´°ç¯€ï¼ˆå°æ¯” ${c.contrast.toFixed(1)}ï¼‰`,params:{xrayMode:"adaptive",xrayK:6.5,xrayDetail:1.4,edge:.7,usmK:2.2,emboss:.25,ckBilateral:!1},badges:["AIæ¨è–¦","æœ€ä½³"]}),(c.contrast<40||l.isLowContrast)&&d.push({label:"ğŸ§Š ä½å°æ¯”å¢å¼·",desc:`CLAHE å¼·åŒ–ï¼ˆå°æ¯” ${c.contrast.toFixed(1)}ï¼ŒÏƒ ${l.stdDev.toFixed(1)}ï¼‰`,params:{xrayMode:"clahe",xrayK:9,xrayDetail:1.8,edge:.95,usmK:2.8,emboss:.15},badges:["å°æ¯”"]}),a>.02&&s>2&&r>6&&d.push({label:"ğŸ”¬ æ¥µé™è§£æ",desc:`æ°£å­”å°ˆç”¨ï¼ˆå£“ç—• ${(1e3*a).toFixed(1)}ï¼Œç†µ ${r.toFixed(1)}ï¼‰`,params:{xrayMode:"adaptive",xrayK:10,xrayDetail:2,edge:1,emboss:.6,usmK:3,ckDeblock:!1},badges:["æ¥µé™","ğŸš€"]}),d.push({label:"ğŸ¯ æ¨™æº–",desc:"å¹³è¡¡æ•ˆæœ",params:{xrayMode:"neutral",xrayK:4.5,xrayDetail:1,edge:.4,usmK:1,ckBilateral:!1},badges:["é è¨­"]}),g.innerHTML="",d.forEach(e=>{const t=document.createElement("div");t.className="ajItem";const n=e.badges?e.badges.map(e=>`<span class="badge">${e}</span>`).join(" "):"";t.innerHTML=`\n        <strong>${e.label}</strong>\n        <span>${e.desc}</span>\n        ${n}\n      `,t.addEventListener("click",()=>{A(e.params,!1,!0),k(`âœ… å·²å¥—ç”¨ ${e.label}`),u.classList.remove("show"),p.classList.remove("active"),b.ajOpen=!1}),g.appendChild(t)}),b.ajOpen||setTimeout(()=>{u.classList.add("show"),p.classList.add("active"),b.ajOpen=!0},900)}!function(){b.workers.forEach(e=>{try{e.terminate()}catch(e){}}),b.workers=[];for(let e=0;e<a;e++){const t=new Worker(D);F(t,e),b.workers.push(t)}}(),p.addEventListener("click",()=>{if(b.ajOpen)u.classList.remove("show"),p.classList.remove("active"),b.ajOpen=!1;else{if(!b.loaded)return void k("ğŸ“¸ è«‹å…ˆè¼‰å…¥åœ–ç‰‡");b.analysisCache?j():(k("â³ æ­£åœ¨åˆ†æ..."),S()),u.classList.add("show"),p.classList.add("active"),b.ajOpen=!0}});let B=.5;d.addEventListener("mousedown",()=>{b.isDragging=!0}),d.addEventListener("touchstart",e=>{b.isDragging=!0,e.preventDefault()},{passive:!1}),document.addEventListener("mousemove",e=>{if(!b.isDragging)return;const t=l.getBoundingClientRect();B=v((e.clientX-t.left)/t.width,0,1),d.style.left=100*B+"%",m.style.clipPath=`inset(0 ${100*(1-B)}% 0 0)`}),document.addEventListener("touchmove",e=>{if(!b.isDragging||!e.touches[0])return;const t=l.getBoundingClientRect();B=v((e.touches[0].clientX-t.left)/t.width,0,1),d.style.left=100*B+"%",m.style.clipPath=`inset(0 ${100*(1-B)}% 0 0)`},{passive:!0}),document.addEventListener("mouseup",()=>{b.isDragging=!1}),document.addEventListener("touchend",()=>{b.isDragging=!1}),l.addEventListener("click",()=>{l.requestFullscreen?l.requestFullscreen():l.webkitRequestFullscreen&&l.webkitRequestFullscreen()});s("btnDL").addEventListener("click",()=>{if(!b.loaded)return alert("è«‹å…ˆè¼‰å…¥åœ–ç‰‡");var e;e="result.png",r.toBlob(t=>{const n=URL.createObjectURL(t),a=document.createElement("a");a.href=n,a.download=e,document.body.appendChild(a),a.click(),document.body.removeChild(a),setTimeout(()=>URL.revokeObjectURL(n),100)},"image/png",.95),k("âœ… å·²ä¸‹è¼‰")}),s("btnDLMask").addEventListener("click",()=>{if(!b.loaded)return alert("è«‹å…ˆè¼‰å…¥åœ–ç‰‡");const e=r.width,t=r.height,n=c.getImageData(0,0,e,t);b.workers[0].postMessage({type:"mask",jobId:Date.now(),w:e,h:t,buf:n.data.buffer},[n.data.buffer]),k("â³ æ­£åœ¨ç”Ÿæˆé®ç½©...")}),s("btnHQ").addEventListener("click",()=>{if(!b.loaded)return alert("è«‹å…ˆè¼‰å…¥åœ–ç‰‡");I(!1),k("â³ é«˜ç•«è³ªè™•ç†...")}),s("btnCancel").addEventListener("click",()=>{b.latest=Date.now()+1e5,clearTimeout(b.processTimeout),y.style.display="none",b.processing=!1,k("ğŸ›‘ å·²å–æ¶ˆ"),R()}),navigator.share&&(s("btnShare").style.display="flex",s("btnShare").addEventListener("click",async()=>{if(!b.loaded)return alert("è«‹å…ˆè¼‰å…¥åœ–ç‰‡");r.toBlob(async e=>{const t=new File([e],"result.png",{type:"image/png"});try{await navigator.share({files:[t],title:"ğŸ‚ Cake Reveal"}),k("âœ… å·²åˆ†äº«")}catch(e){"AbortError"!==e.name&&k("âŒ åˆ†äº«å¤±æ•—")}},"image/png",.95)}));const C={pv:800,ckDeblock:!1,ckBilateral:!1,fbSigma:1.2,bilatR:30,bilatS:30,ckEnh:!0,usmK:1,edge:.4,emboss:.2,shadow:.4,blur:0,ckXray:!0,xrayMode:"neutral",xrayK:4.5,xrayDetail:1,ckHeat:!1,heatA:.6};function E(){document.querySelectorAll(".xray-group").forEach(e=>{e.classList.toggle("hidden",!s("ckXray").checked)}),document.querySelectorAll(".heat-group").forEach(e=>{e.classList.toggle("hidden",!s("ckHeat").checked)})}s("btnReset").addEventListener("click",()=>{A(C),b.autoApplied=!1,f.classList.remove("show"),k("âš™ï¸ å·²é‡ç½®")}),s("btnCopy").addEventListener("click",async()=>{const e=JSON.stringify(M());try{await navigator.clipboard.writeText(e),k("âœ… å·²è¤‡è£½")}catch{b.clipboard=e,k("âœ… å·²è¤‡è£½ï¼ˆå…§éƒ¨ï¼‰")}}),s("btnPaste").addEventListener("click",async()=>{try{const e=await navigator.clipboard.readText();A(JSON.parse(e)),k("âœ… å·²è²¼ä¸Š")}catch{if(!b.clipboard)return k("âŒ å‰ªè²¼ç°¿ç©º");A(JSON.parse(b.clipboard)),k("âœ… å·²è²¼ä¸Š")}});function $(){document.querySelectorAll("button:not(#btnCancel)").forEach(e=>e.disabled=!0)}function R(){document.querySelectorAll("button").forEach(e=>e.disabled=!1)}["pv","fbSigma","bilatR","bilatS","usmK","edge","emboss","shadow","blur","xrayK","xrayDetail","heatA"].forEach(e=>{const t=s(e);t.addEventListener("input",()=>{const n=s(e+"_v");n&&(n.textContent=t.value),b.autoApplied&&(b.autoApplied=!1,f.classList.remove("show")),Y()})}),["ckDeblock","ckBilateral","ckEnh","ckXray","ckHeat"].forEach(e=>{s(e).addEventListener("change",()=>{E(),Y()})}),s("xrayMode").addEventListener("change",Y),document.addEventListener("keydown",e=>{if("INPUT"===e.target.tagName||"SELECT"===e.target.tagName)return;const t=e.key.toLowerCase();"o"===t&&(s("fileInput").click(),e.preventDefault()),"h"===t&&(s("btnHQ").click(),e.preventDefault()),"s"===t&&(s("btnDL").click(),e.preventDefault())}),E(),R(),console.log("âœ… v12.0 AIå¢å¼·ç‰ˆåˆå§‹åŒ–å®Œæˆ"),console.log("ã€æ–°åŠŸèƒ½ã€‘"),console.log("âœ… æ™ºèƒ½æ¸¬å…‰åˆ†æï¼šæ›å…‰/å™ªé»/å‹•æ…‹ç¯„åœè‡ªå‹•æª¢æ¸¬"),console.log("âœ… 8ç¨®AIæ¨è–¦ï¼šæ›å…‰ä¿®å¾©/é™å™ª/æ¥µé™è§£æ/å®Œç¾å¢å¼·ç­‰"),console.log("âœ… Guided Filter ç´°ç¯€å¢å¼·ï¼šå¤šå°ºåº¦è‡ªé©æ‡‰ç´°ç¯€æå–"),console.log("ã€å„ªåŒ–ã€‘"),console.log("âœ… 21é …åŠŸèƒ½å…¨éƒ¨å®Œæ•´ä¿ç•™"),console.log("âœ… Stack Blur å®Œæ•´é‚Šç•Œä¿®å¾©"),console.log("âœ… Bilateral å„ªåŒ–ç‰ˆæœ¬"),console.log("âœ… CLAHE é‚Šç•Œå¹³æ»‘"),console.log("âœ… è¨˜æ†¶é«”æ´©æ¼ä¿®å¾© + è¶…æ™‚ä¿è­·"),console.log("âœ… Canvas context ç‹€æ…‹æ¸…ç†")}n()?(document.getElementById("loginScreen").classList.add("hidden"),document.getElementById("mainApp").style.display="flex"):(document.getElementById("loginForm").addEventListener("submit",function(n){n.preventDefault();const s=document.getElementById("username").value.trim(),o=document.getElementById("password").value.trim(),r=document.getElementById("errorMsg");s===e&&"1234"===o?(sessionStorage.setItem(t,JSON.stringify({username:s,timestamp:Date.now()})),document.getElementById("loginScreen").classList.add("hidden"),document.getElementById("mainApp").style.display="flex",setTimeout(a,100)):(r.classList.add("show"),document.getElementById("password").value="",document.getElementById("password").focus(),setTimeout(()=>{r.classList.remove("show")},3e3))}),document.getElementById("username").focus()),n()&&a()}()</script></body></html>